<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhouyifan.net","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在过去的大半年里，以Stable Diffusion为代表的AI绘画是世界上最为火热的AI方向之一。或许大家会有疑问，Stable Diffusion里的这个”Diffusion”是什么意思？其实，扩散模型(Diffusion Model)正是Stable Diffusion中负责生成图像的模型。想要理解Stable Diffusion的原理，就一定绕不过扩散模型的学习。  在这篇文章里，我会由浅">
<meta property="og:type" content="article">
<meta property="og:title" content="扩散模型(Diffusion Model)详解：直观理解、数学原理、PyTorch 实现">
<meta property="og:url" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/index.html">
<meta property="og:site_name" content="周弈帆的博客">
<meta property="og:description" content="在过去的大半年里，以Stable Diffusion为代表的AI绘画是世界上最为火热的AI方向之一。或许大家会有疑问，Stable Diffusion里的这个”Diffusion”是什么意思？其实，扩散模型(Diffusion Model)正是Stable Diffusion中负责生成图像的模型。想要理解Stable Diffusion的原理，就一定绕不过扩散模型的学习。  在这篇文章里，我会由浅">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/1.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/2.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/3.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/4.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/5.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/6.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/7.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/c1.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/c2.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/7.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/6.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/c3.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/c4.jpg">
<meta property="article:published_time" content="2023-07-07T12:56:55.000Z">
<meta property="article:modified_time" content="2023-09-27T16:19:04.540Z">
<meta property="article:author" content="Zhou Yifan">
<meta property="article:tag" content="深度学习">
<meta property="article:tag" content="扩散模型">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/1.jpg">

<link rel="canonical" href="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>扩散模型(Diffusion Model)详解：直观理解、数学原理、PyTorch 实现 | 周弈帆的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">周弈帆的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/2023/07/07/20230330-diffusion-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="A foresighted strategist with big-picture thinking. 大局观选手。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          扩散模型(Diffusion Model)详解：直观理解、数学原理、PyTorch 实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-07 20:56:55" itemprop="dateCreated datePublished" datetime="2023-07-07T20:56:55+08:00">2023-07-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">知识整理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在过去的大半年里，以Stable Diffusion为代表的AI绘画是世界上最为火热的AI方向之一。或许大家会有疑问，Stable Diffusion里的这个”Diffusion”是什么意思？其实，扩散模型(Diffusion Model)正是Stable Diffusion中负责生成图像的模型。想要理解Stable Diffusion的原理，就一定绕不过扩散模型的学习。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/1.jpg" alt="Stable Diffusion以「毕加索笔下的《最后的晚餐》」为题的绘画结果"></p>
<p>在这篇文章里，我会由浅入深地对最基础的去噪扩散概率模型（Denoising Diffusion Probabilistic Models, DDPM）进行讲解。我会先介绍扩散模型生成图像的基本原理，再用简单的数学语言对扩散模型建模，最后给出扩散模型的一份PyTorch实现。本文不会堆砌过于复杂的数学公式，哪怕你没有相关的数学背景，也能够轻松理解扩散模型的原理。</p>
<h2 id="扩散模型与图像生成"><a href="#扩散模型与图像生成" class="headerlink" title="扩散模型与图像生成"></a>扩散模型与图像生成</h2><p>在认识扩散模型之前，我们先退一步，看看一般的神经网络模型是怎么生成图像的。显然，为了生成丰富的图像，一个图像生成程序要根据随机数来生成图像。通常，这种随机数是一个满足标准正态分布的随机向量。这样，每次要生成新图像时，只需要从标准正态分布里随机生成一个向量并输入给程序就行了。</p>
<p>而在AI绘画程序中，负责生成图像的是一个神经网络模型。神经网络需要从数据中学习。对于图像生成任务，神经网络的训练数据一般是一些同类型的图片。比如一个绘制人脸的神经网络会用人脸照片来训练。也就是说，神经网络会学习如何把一个向量映射成一张图片，并确保这个图片和训练集的图片是一类图片。</p>
<p>可是，相比其他AI任务，图像生成任务对神经网络来说更加困难一点——图像生成任务缺乏有效的指导。在其他AI任务中，训练集本身会给出一个「标准答案」，指导AI的输出向标准答案靠拢。比如对于图像分类任务，训练集会给出每一幅图像的类别；对于人脸验证任务，训练集会给出两张人脸照片是不是同一个人；对于目标检测任务，训练集会给出目标的具体位置。然而，图像生成任务是没有标准答案的。图像生成数据集里只有一些同类型图片，却没有指导AI如何画得更好的信息。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/2.jpg" alt></p>
<p>为了解决这一问题，人们专门设计了一些用于生成图像的神经网络架构。这些架构中比较出名的有生成对抗模型（GAN）和变分自编码器（VAE）。</p>
<p>GAN的想法是，既然不知道一幅图片好不好，就干脆再训练一个神经网络，用于辨别某图片是不是和训练集里的图片长得一样。生成图像的神经网络叫做生成器，鉴定图像的神经网络叫做判别器。两个网络互相对抗，共同进步。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/3.jpg" alt></p>
<p>VAE则使用了逆向思维：学习向量生成图像很困难，那就再同时学习怎么用图像生成向量。这样，把某图像变成向量，再用该向量生成图像，就应该得到一幅和原图像一模一样的图像。每一个向量的绘画结果有了一个标准答案，可以用一般的优化方法来指导网络的训练了。VAE中，把图像变成向量的网络叫做编码器，把向量转换回图像的网络叫做解码器。其中，解码器就是负责生成图像的模型。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/4.jpg" alt></p>
<p>一直以来，GAN的生成效果较好，但训练起来比VAE麻烦很多。有没有和GAN一样强大，训练起来又方便的生成网络架构呢？扩散模型正是满足这些要求的生成网络架构。</p>
<p>扩散模型是一种特殊的VAE，其灵感来自于热力学：一个分布可以通过不断地添加噪声变成另一个分布。放到图像生成任务里，就是来自训练集的图像可以通过不断添加噪声变成符合标准正态分布的图像。从这个角度出发，我们可以对VAE做以下修改：1）不再训练一个可学习的编码器，而是把编码过程固定成不断添加噪声的过程；2）不再把图像压缩成更短的向量，而是自始至终都对一个等大的图像做操作。解码器依然是一个可学习的神经网络，它的目的也同样是实现编码的逆操作。不过，既然现在编码过程变成了加噪，那么解码器就应该负责去噪。而对于神经网络来说，去噪任务学习起来会更加有效。因此，扩散模型既不会涉及GAN中复杂的对抗训练，又比VAE更强大一点。</p>
<p>具体来说，扩散模型由<strong>正向过程</strong>和<strong>反向过程</strong>这两部分组成，对应VAE中的编码和解码。在正向过程中，输入$\mathbf{x}_0$会不断混入高斯噪声。经过$T$次加噪声操作后，图像$\mathbf{x}_T$会变成一幅符合标准正态分布的纯噪声图像。而在反向过程中，我们希望训练出一个神经网络，该网络能够学会$T$个去噪声操作，把$\mathbf{x}_T$还原回$\mathbf{x}_0$。网络的学习目标是让$T$个去噪声操作正好能抵消掉对应的加噪声操作。训练完毕后，只需要从标准正态分布里随机采样出一个噪声，再利用反向过程里的神经网络把该噪声恢复成一幅图像，就能够生成一幅图片了。</p>
<blockquote>
<p>高斯噪声，就是一幅各处颜色值都满足高斯分布（正态分布）的噪声图像。</p>
</blockquote>
<p><img src="/2023/07/07/20230330-diffusion-model/5.jpg" alt></p>
<p>总结一下，图像生成网络会学习如何把一个向量映射成一幅图像。设计网络架构时，最重要的是设计学习目标，让网络生成的图像和给定数据集里的图像相似。VAE的做法是使用两个网络，一个学习把图像编码成向量，另一个学习把向量解码回图像，它们的目标是让复原图像和原图像尽可能相似。学习完毕后，解码器就是图像生成网络。扩散模型是一种更具体的VAE。它把编码过程固定为加噪声，并让解码器学习怎么样消除之前添加的每一步噪声。</p>
<h2 id="扩散模型的具体算法"><a href="#扩散模型的具体算法" class="headerlink" title="扩散模型的具体算法"></a>扩散模型的具体算法</h2><p>上一节中，我们只是大概了解扩散模型的整体思想。这一节，我们来引入一些数学表示，来看一看扩散模型的训练算法和采样算法具体是什么。为了便于理解，这一节会出现一些不是那么严谨的数学描述。更加详细的一些数学推导会放到下一节里介绍。</p>
<h3 id="前向过程"><a href="#前向过程" class="headerlink" title="前向过程"></a>前向过程</h3><p>在前向过程中，来自训练集的图像$\mathbf{x}_0$会被添加$T$次噪声，使得$x_T$为符合标准正态分布。准确来说，「加噪声」并不是给上一时刻的图像加上噪声值，而是从一个均值与上一时刻图像相关的正态分布里采样出一幅新图像。如下面的公式所示，$\mathbf{x}_{t - 1}$是上一时刻的图像，$\mathbf{x}_{t}$是这一时刻生成的图像，该图像是从一个均值与$\mathbf{x}_{t - 1}$有关的正态分布里采样出来的。</p>
<script type="math/tex; mode=display">
\mathbf{x}_t \sim \mathcal{N}(\mu_t(\mathbf{x}_{t - 1}),\sigma_t^2\mathbf{I})</script><blockquote>
<p>多数文章会说前向过程是一个<strong>马尔可夫过程</strong>。其实，马尔可夫过程的意思就是当前时刻的状态只由上一时刻的状态决定，而不由更早的状态决定。上面的公式表明，计算$\mathbf{x}_t$，只需要用到$\mathbf{x}_{t - 1}$，而不需要用到$\mathbf{x}_{t - 2}, \mathbf{x}_{t - 3}…$，这符合马尔可夫过程的定义。</p>
</blockquote>
<p>绝大多数扩散模型会把这个正态分布设置成这个形式：</p>
<script type="math/tex; mode=display">
\mathbf{x}_t \sim \mathcal{N}(\sqrt{1 - \beta_t}\mathbf{x}_{t - 1},\beta_t\mathbf{I})</script><p>这个正态分布公式乍看起来很奇怪：$\sqrt{1 - \beta_t}$是哪里冒出来的？为什么会有这种奇怪的系数？别急，我们先来看另一个问题：假如给定$\mathbf{x}_{0}$，也就是从训练集里采样出一幅图片，该怎么计算任意一个时刻$t$的噪声图像$\mathbf{x}_{t}$呢？</p>
<p>我们不妨按照公式，从$\mathbf{x}_{t}$开始倒推。$\mathbf{x}_{t}$其实可以通过一个标准正态分布的样本$\epsilon_{t-1}$算出来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{x}_t &\sim \mathcal{N}(\sqrt{1 - \beta_t}\mathbf{x}_{t - 1},\beta_t\mathbf{I}) \\
\Rightarrow \mathbf{x}_t &= \sqrt{1 - \beta_t}\mathbf{x}_{t - 1} + \sqrt{\beta_t}\epsilon_{t-1}; \epsilon_{t-1} \sim \mathcal{N}(0, \mathbf{I})
\end{aligned}</script><p>再往前推几步：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{x}_t &= \sqrt{1 - \beta_t}\mathbf{x}_{t - 1} + \sqrt{\beta_t}\epsilon_{t-1}\\
 &= \sqrt{1 - \beta_t}(\sqrt{1 - \beta_{t-1}}\mathbf{x}_{t - 2} + \sqrt{\beta_{t-1}}\epsilon_{t-2}) + \sqrt{\beta_t}\epsilon_{t-1}
 \\
&= \sqrt{(1 - \beta_t)(1 - \beta_{t-1})}\mathbf{x}_{t - 2} + \sqrt{(1 - \beta_t)\beta_{t-1}}\epsilon_{t-2} + \sqrt{\beta_t}\epsilon_{t-1}
\end{aligned}</script><p>由正态分布的性质可知，均值相同的正态分布「加」在一起后，方差也会加到一起。也就是$\mathcal{N}(0, \sigma_1^2 I)$与$\mathcal{N}(0, \sigma_2^2 I)$合起来会得到$\mathcal{N}(0, (\sigma_1^2+\sigma_2^2) I)$。根据这一性质，上面的公式可以化简为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sqrt{(1 - \beta_t)(1 - \beta_{t-1})}\mathbf{x}_{t - 2} + \sqrt{(1 - \beta_t)\beta_{t-1}}\epsilon_{t-2} + \sqrt{\beta_t}\epsilon_{t-1} \\
= & \sqrt{(1 - \beta_t)(1 - \beta_{t-1})}\mathbf{x}_{t - 2} + \sqrt{(1 - \beta_t)\beta_{t-1} + \beta_t}\epsilon \\
= & \sqrt{(1 - \beta_t)(1 - \beta_{t-1})}\mathbf{x}_{t - 2} + \sqrt{1-(1-\beta_t)(1-\beta_{t-1})}\epsilon
\end{aligned}</script><p>再往前推一步的话，结果是：</p>
<script type="math/tex; mode=display">
\sqrt{(1 - \beta_t)(1 - \beta_{t-1})(1 - \beta_{t-2})}\mathbf{x}_{t - 3} + \sqrt{1-(1-\beta_t)(1-\beta_{t-1})(1 - \beta_{t-2})}\epsilon</script><p>我们已经能够猜出规律来了，可以一直把公式推到$\mathbf{x}_{0}$。令$\alpha_t=1-\beta_t, \bar{\alpha}_t=\prod_{i=1}^t\alpha_i$，则：</p>
<script type="math/tex; mode=display">
\mathbf{x}_t = \sqrt{\bar{\alpha}_t}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_t}\epsilon</script><p>有了这个公式，我们就可以讨论加噪声公式为什么是$\mathbf{x}_t \sim \mathcal{N}(\sqrt{1 - \beta_t}\mathbf{x}_{t - 1},\beta_t\mathbf{I})$了。这个公式里的$\beta_t$是一个小于1的常数。在DDPM论文中，$\beta_t$从$\beta_1=10^{-4}$到$\beta_T=0.02$线性增长。这样，$\beta_t$变大，$\alpha_t$也越小，$\bar{\alpha}_t$趋于0的速度越来越快。最后，$\bar{\alpha}_T$几乎为0，代入$\mathbf{x}_T = \sqrt{\bar{\alpha}_T}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_T}\epsilon$, $\mathbf{x}_T$就满足标准正态分布了，符合我们对扩散模型的要求。上述推断可以简单描述为：加噪声公式能够从慢到快地改变原图像，让图像最终均值为0，方差为$\mathbf{I}$。</p>
<blockquote>
<p>大家不妨尝试一下，设加噪声公式中均值和方差前的系数分别为$a, b$，按照上述过程计算最终分布的方差。只有$a^2 + b^2 = 1$才能保证最后$\mathbf{x}_T$的方差系数为1。</p>
</blockquote>
<h3 id="反向过程"><a href="#反向过程" class="headerlink" title="反向过程"></a>反向过程</h3><p>在正向过程中，我们人为设置了$T$步加噪声过程。而在反向过程中，我们希望能够倒过来取消每一步加噪声操作，让一幅纯噪声图像变回数据集里的图像。这样，利用这个去噪声过程，我们就可以把任意一个从标准正态分布里采样出来的噪声图像变成一幅和训练数据长得差不多的图像，从而起到图像生成的目的。</p>
<p>现在问题来了：去噪声操作的数学形式是怎么样的？怎么让神经网络来学习它呢？数学原理表明，当$\beta_t$足够小时，每一步加噪声的逆操作也满足正态分布。</p>
<script type="math/tex; mode=display">
\mathbf{x}_{t-1} \sim \mathcal{N}(\tilde{\mu}_t, \tilde{\beta}_t\mathbf{I})</script><p>其中，当前时刻加噪声逆操作的均值$\tilde{\mu}_t$和方差$\tilde{\beta}_t$由当前的时刻$t$、当前的图像$\mathbf{x}_{t}$决定。因此，为了描述所有去噪声操作，神经网络应该输入$t$、$\mathbf{x}_{t}$，拟合当前的均值$\tilde{\mu}_t$和方差$\tilde{\beta}_t$。</p>
<blockquote>
<p>不要被上文的「去噪声」、「加噪声逆操作」绕晕了哦。由于加噪声是固定的，加噪声的逆操作也是固定的。理想情况下，我们希望去噪操作就等于加噪声逆操作。然而，加噪声的逆操作不太可能从理论上求得，我们只能用一个神经网络去拟合它。去噪声操作和加噪声逆操作的关系，就是神经网络的预测值和真值的关系。</p>
</blockquote>
<p>现在问题来了：加噪声逆操作的均值和方差是什么？</p>
<p>直接计算所有数据的加噪声逆操作的分布是不太现实的。但是，如果给定了某个训练集输入$\mathbf{x}_0$，多了一个限定条件后，该分布是可以用贝叶斯公式计算的（其中$q$表示概率分布）：</p>
<script type="math/tex; mode=display">
q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) = q(\mathbf{x}_{t} | \mathbf{x}_{t - 1}, \mathbf{x}_0)\frac{q(\mathbf{x}_{t-1} | \mathbf{x}_0)}{q(\mathbf{x}_{t} | \mathbf{x}_0)}</script><p>等式左边的$q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0)=\mathcal{N}(\mathbf{x}_{t-1};\tilde{\mu}_t, \tilde{\beta}_t\mathbf{I})$表示加噪声操作的逆操作，它的均值和方差都是待求的。右边的$q(\mathbf{x}_{t} | \mathbf{x}_{t-1}, \mathbf{x}_0)=\mathcal{N}(\mathbf{x}_{t};\sqrt{1 - \beta_t}\mathbf{x}_{t - 1},\beta_t\mathbf{I})$是加噪声的分布。而由于$\mathbf{x}_0$已知，$q(\mathbf{x}_{t-1} | \mathbf{x}_0)$和$q(\mathbf{x}_{t} | \mathbf{x}_0)$两项可以根据前面的公式$\mathbf{x}_t = \sqrt{\bar{\alpha}_t}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_t}\epsilon_t$得来：</p>
<script type="math/tex; mode=display">
\begin{aligned}
q(\mathbf{x}_{t} | \mathbf{x}_0)&=\mathcal{N}(\mathbf{x}_{t}; \sqrt{\bar{\alpha}_t}\mathbf{x}_{0}, (1-\bar{\alpha}_t)\mathbf{I}) \\
q(\mathbf{x}_{t-1} | \mathbf{x}_0)&=\mathcal{N}(\mathbf{x}_{t-1}; \sqrt{\bar{\alpha}_{t-1}}\mathbf{x}_{0}, (1-\bar{\alpha}_{t-1})\mathbf{I})
\end{aligned}</script><p>这样，等式右边的式子全部已知。我们可以把公式套入，算出给定$\mathbf{x}_0$时的去噪声分布。经计算化简，分布的均值为:</p>
<script type="math/tex; mode=display">
\tilde{\mu}_t = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_t)</script><p>其中，$\epsilon_t$是用公式算$\mathbf{x}_t$时从标准正态分布采样出的样本，它来自公式</p>
<script type="math/tex; mode=display">
\mathbf{x}_t = \sqrt{\bar{\alpha}_t}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_t}\epsilon_t</script><p>分布的方差为：</p>
<script type="math/tex; mode=display">
\tilde{\beta}_t=\frac{1-\bar{\alpha}_{t-1}}{1 - \bar{\alpha}_{t}} \cdot \beta_t</script><p>注意，$\beta_t$是加噪声的方差，是一个常量。那么，加噪声逆操作的方差$\tilde{\beta}_t$也是一个常量，不与输入$\mathbf{x}_0$相关。这下就省事了，训练去噪网络时，神经网络只用拟合$T$个均值就行，不用再拟合方差了。</p>
<p>知道了均值和方差的真值，训练神经网络只差最后的问题了：该怎么设置训练的损失函数？加噪声逆操作和去噪声操作都是正态分布，网络的训练目标应该是让每对正态分布更加接近。那怎么用损失函数描述两个分布尽可能接近呢？最直观的想法，肯定是让两个正态分布的均值尽可能接近，方差尽可能接近。根据上文的分析，方差是常量，只用让均值尽可能接近就可以了。</p>
<p>那怎么用数学公式表达让均值更接近呢？再观察一下目标均值的公式：</p>
<script type="math/tex; mode=display">
\tilde{\mu}_t = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_t)</script><p>神经网络拟合均值时，$\mathbf{x}_{t}$是已知的（别忘了，图像是一步一步倒着去噪的）。式子里唯一不确定的只有$\epsilon_t$。既然如此，神经网络干脆也别预测均值了，直接预测一个噪声$\epsilon_\theta(\mathbf{x}_{t}, t)$（其中$\theta$为可学习参数），让它和生成$\mathbf{x}_{t}$的噪声$\epsilon_t$的均方误差最小就行了。对于一轮训练，最终的误差函数可以写成</p>
<script type="math/tex; mode=display">
L=||\epsilon_t - \epsilon_\theta(\mathbf{x}_{t}, t)||^2</script><p>这样，我们就认识了反向过程的所有内容。总结一下，反向过程中，神经网络应该让$T$个去噪声操作拟合对应的$T$个加噪声逆操作。每步加噪声逆操作符合正态分布，且在给定某个输入时，该正态分布的均值和方差是可以用解析式表达出来的。因此，神经网络的学习目标就是让其输出的去噪声分布和理论计算的加噪声逆操作分布一致。经过数学计算上的一些化简，问题被转换成了拟合生成$\mathbf{x}_{t}$时用到的随机噪声$\epsilon_t$。</p>
<h3 id="训练算法与采样算法"><a href="#训练算法与采样算法" class="headerlink" title="训练算法与采样算法"></a>训练算法与采样算法</h3><p>理解了前向过程和反向过程后，训练神经网络的算法和采样图片（生成图片）的算法就呼之欲出了。</p>
<p>以下是DDPM论文中的训练算法：</p>
<p><img src="/2023/07/07/20230330-diffusion-model/6.jpg" alt></p>
<p>让我们来逐行理解一下这个算法。第二行是指从训练集里取一个数据$\mathbf{x}_{0}$。第三行是指随机从$1, …, T$里取一个时刻用来训练。我们虽然要求神经网络拟合$T$个正态分布，但实际训练时，不用一轮预测$T$个结果，只需要随机预测$T$个时刻中某一个时刻的结果就行。第四行指随机生成一个噪声$\epsilon$，该噪声是用于执行前向过程生成$\mathbf{x}_t = \sqrt{\bar{\alpha}_t}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_t}\epsilon$的。之后，我们把$\mathbf{x}_t$和$t$传给神经网络$\epsilon_\theta(\mathbf{x}_{t}, t)$，让神经网络预测随机噪声。训练的损失函数是预测噪声和实际噪声之间的均方误差，对此损失函数采用梯度下降即可优化网络。</p>
<p>DDPM并没有规定神经网络的结构。根据任务的难易程度，我们可以自己定义简单或复杂的网络结构。这里只需要把$\epsilon_\theta(\mathbf{x}_{t}, t)$当成一个普通的映射即可。</p>
<p>训练好了网络后，我们可以执行反向过程，对任意一幅噪声图像去噪，以实现图像生成。这个算法如下：</p>
<p><img src="/2023/07/07/20230330-diffusion-model/7.jpg" alt></p>
<p>第一行的$\mathbf{x}_{T}$就是从标准正态分布里随机采样的输入噪声。要生成不同的图像，只需要更换这个噪声。后面的过程就是扩散模型的反向过程。令时刻从$T$到$1$，计算这一时刻去噪声操作的均值和方差，并采样出$\mathbf{x}_{t-1}$。均值是用之前提到的公式计算的：</p>
<script type="math/tex; mode=display">
\mu_{\theta}(\mathbf{x}_{t}, t) = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_\theta(\mathbf{x}_{t}, t))
\\</script><p>而方差$\sigma_t^2$的公式有两种选择，两个公式都能产生差不多的结果。实验表明，当$\mathbf{x}_{0}$是特定的某个数据时，用上一节推导出来的方差最好。</p>
<script type="math/tex; mode=display">
\sigma_t^2=\frac{1-\bar{\alpha}_{t-1}}{1 - \bar{\alpha}_{t}} \cdot \beta_t</script><p>而当$\mathbf{x}_{0} \sim \mathcal{N}(0, \mathbf{I})$时，只需要令方差和加噪声时的方差一样即可。</p>
<script type="math/tex; mode=display">
\sigma_t^2= \beta_t</script><p>循环执行去噪声操作。最后生成的$\mathbf{x}_{0}$就是生成出来的图像。</p>
<p>特别地，最后一步去噪声是不用加方差项的。为什么呢，观察公式$\sigma_t^2=\frac{1-\bar{\alpha}_{t-1}}{1 - \bar{\alpha}_{t}} \cdot \beta_t$。当$t=1$时，分子会出现$\bar{\alpha}_{t-1}=\bar{\alpha}_0$这一项。$\bar{\alpha}_t$是一个连乘，理论上$t$是从$1$开始的，在$t=0$时没有定义。但我们可以特别地令连乘的第0项$\bar{\alpha}_0=1$。这样，$t=1$时方差项的分子$1-\bar{\alpha}_{t-1}$为$0$，不用算这一项了。</p>
<blockquote>
<p>当然，这一解释从数学上来说是不严谨的。据论文说，这部分的解释可以参见朗之万动力学。</p>
</blockquote>
<h2 id="数学推导的补充-（选读）"><a href="#数学推导的补充-（选读）" class="headerlink" title="数学推导的补充 （选读）"></a>数学推导的补充 （选读）</h2><p>理解了训练算法和采样算法，我们就算是搞懂了扩散模型，可以去编写代码了。不过，上文的描述省略了一些数学推导的细节。如果对扩散模型更深的原理感兴趣，可以阅读一下本节。</p>
<h3 id="加噪声逆操作均值和方差的推导"><a href="#加噪声逆操作均值和方差的推导" class="headerlink" title="加噪声逆操作均值和方差的推导"></a>加噪声逆操作均值和方差的推导</h3><p>上一节，我们根据下面几个式子</p>
<script type="math/tex; mode=display">
\begin{aligned}
q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) = q(\mathbf{x}_{t} | \mathbf{x}_{t - 1}, \mathbf{x}_0)\frac{q(\mathbf{x}_{t-1} | \mathbf{x}_0)}{q(\mathbf{x}_{t} | \mathbf{x}_0)} \\
q(\mathbf{x}_{t} | \mathbf{x}_0)=\mathcal{N}(\mathbf{x}_{t}; \sqrt{\bar{\alpha}_t}\mathbf{x}_{0}, (1-\bar{\alpha}_t)\mathbf{I})\\
q(\mathbf{x}_{t} | \mathbf{x}_{t-1}, \mathbf{x}_0)=\mathcal{N}(\mathbf{x}_{t};\sqrt{1 - \beta_t}\mathbf{x}_{t - 1},\beta_t\mathbf{I})
\end{aligned}</script><p>一步就给出了$q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0)=\mathcal{N}(\mathbf{x}_{t-1}; \tilde{\mu}_t, \tilde{\beta}_t\mathbf{I})$的均值和方差。</p>
<script type="math/tex; mode=display">
\tilde{\mu}_t = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_t)</script><script type="math/tex; mode=display">
\tilde{\beta}_t=\frac{1-\bar{\alpha}_{t-1}}{1 - \bar{\alpha}_{t}} \cdot \beta_t</script><p>现在我们来看一下推导均值和方差的思路。</p>
<p>首先，把其他几个式子带入贝叶斯公式的等式右边。</p>
<script type="math/tex; mode=display">
\begin{aligned}
q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) = &
\frac{1}{\beta_t\sqrt{2\pi}}exp(-\frac{(\mathbf{x}_{t}-\sqrt{1 - \beta_t}\mathbf{x}_{t - 1})^2}{2\beta_t}) \cdot \\

&\frac{1}{(1-\bar{\alpha}_{t-1})\sqrt{2\pi}} exp(-\frac{(\mathbf{x}_{t-1}-\sqrt{\bar{\alpha}_{t-1}} \mathbf{x}_{0})^2}{2(1-\bar{\alpha}_{t-1})})\cdot \\

&(\frac{1}{(1-\bar{\alpha}_t)\sqrt{2\pi}} exp(-\frac{(\mathbf{x}_{t}-\sqrt{\bar{\alpha}_{t}} \mathbf{x}_{0})^2}{2(1-\bar{\alpha}_{t})}))^{-1}



\end{aligned}</script><p>由于多个正态分布的乘积还是一个正态分布，我们知道$q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0)$也可以用一个正态分布公式$\mathcal{N}(\mathbf{x}_{t-1}; \tilde{\mu}_t, \tilde{\beta}_t\mathbf{I})$表达，它最后一定能写成这种形式：</p>
<script type="math/tex; mode=display">
q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) = \frac{1}{\tilde{\beta}_t\sqrt{2\pi}}exp(-\frac{(\mathbf{x}_{t-1}-\tilde{\mu}_t)^2}{2\tilde{\beta}_t})</script><p>问题就变成了怎么把开始那个很长的式子化简，算出$\tilde{\mu}_t$和$\tilde{\beta}_t$。</p>
<p>方差$\tilde{\beta}_t$可以从指数函数的系数得来，比较好求。系数为</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\frac{1}{\beta_t\sqrt{2\pi}} \cdot \frac{1}{(1-\bar{\alpha}_{t-1})\sqrt{2\pi}} \cdot (\frac{1}{(1-\bar{\alpha}_t)\sqrt{2\pi}})^{-1} \\
=&\frac{(1-\bar{\alpha}_t)}{\beta_t(1-\bar{\alpha}_{t-1})\sqrt{2\pi}}
\end{aligned}</script><p>所以，方差为：</p>
<script type="math/tex; mode=display">
\tilde{\beta}_t=\frac{1-\bar{\alpha}_{t-1}}{1 - \bar{\alpha}_{t}} \cdot \beta_t</script><p>接下来只要关注指数函数的指数部分。指数部分一定是一个关于的$\mathbf{x}_{t-1}$的二次函数，只要化简成$(\mathbf{x}_{t-1}-C)^2$的形式，再除以一下$-2$倍方差，就可以得到均值了。</p>
<p>指数部分为：</p>
<script type="math/tex; mode=display">
-\frac{1}{2}(\frac{(\mathbf{x}_{t}-\sqrt{1 - \beta_t}\mathbf{x}_{t - 1})^2}{\beta_t}+\frac{(\mathbf{x}_{t-1}-\sqrt{\bar{\alpha}_{t-1}} \mathbf{x}_{0})^2}{1-\bar{\alpha}_{t-1}} - \frac{(\mathbf{x}_{t}-\sqrt{\bar{\alpha}_{t}} \mathbf{x}_{0})^2}{1-\bar{\alpha}_{t}})</script><p>$\mathbf{x}_{t-1}$只在前两项里有。把和$\mathbf{x}_{t-1}$有关的项计算化简，可以计算出均值：</p>
<script type="math/tex; mode=display">
\tilde{\mu}_t = \frac{\sqrt{\alpha_t}(1-\bar{\alpha}_{t-1})}{1 - \bar{\alpha}_{t}}\mathbf{x}_{t}+\frac{\sqrt{\bar{\alpha}_{t-1}}\beta_t}{1 - \bar{\alpha}_{t}}\mathbf{x}_{0}</script><p>回想一下，在去噪声中，神经网络的输入是$\mathbf{x}_{t}$和$t$。也就是说，上式中$\mathbf{x}_{t}$已知，只有$\mathbf{x}_{0}$一个未知量。要算均值，还需要算出$\mathbf{x}_{0}$。$\mathbf{x}_{0}$和$\mathbf{x}_{t}$之间是有一定联系的。$\mathbf{x}_{t}$是$\mathbf{x}_{0}$在正向过程中第$t$步加噪声的结果。而根据正向过程的公式倒推：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{x}_t &= \sqrt{\bar{\alpha}_t}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_t}\epsilon_t \\
\mathbf{x}_0 &= \frac{\mathbf{x}_t - \sqrt{1-\bar{\alpha}_t}\epsilon_t}{\sqrt{\bar{\alpha}_t}}
\end{aligned}</script><p>把这个$\mathbf{x}_{0}$带入均值公式，均值最后会化简成我们熟悉的形式。</p>
<script type="math/tex; mode=display">
\tilde{\mu}_t = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_t)</script><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>上一节，我们只是简单地说神经网络的优化目标是让加噪声和去噪声的均值接近。而让均值接近，就是让生成$\mathbf{x}_t$的噪声$\epsilon_t$更接近。实际上，这个优化目标是经过简化得来的。扩散模型最早的优化目标是有一定的数学意义的。</p>
<p>扩散模型，全称为扩散概率模型（Diffusion Probabilistic Model）。最简单的一类扩散模型，是去噪扩散概率模型（Denoising Diffusion Probabilistic Model），也就是常说的DDPM。DDPM的框架主要是由两篇论文建立起来的。第一篇论文是首次提出扩散模型思想的<em>Deep Unsupervised Learning using Nonequilibrium Thermodynamics</em>。在此基础上，<em>Denoising Diffusion Probabilistic Models</em>对最早的扩散模型做出了一定的简化，让图像生成效果大幅提升，促成了扩散模型的广泛使用。我们上一节看到的公式，全部是简化后的结果。</p>
<p>扩散概率模型的名字之所以有「概率」二字，是因为这个模型是在描述一个系统的概率。准确来说，扩散模型是在描述经反向过程生成出某一项数据的概率。也就是说，扩散模型$p_{\theta}(\mathbf{x}_0)$是一个有着可训练参数$\theta$的模型，它描述了反向过程生成出数据$\mathbf{x}_0$的概率。$p_{\theta}(\mathbf{x}_0)$满足$p_{\theta}(\mathbf{x}_0)=\int p_{\theta}(\mathbf{x}_{0:T})d\mathbf{x}_{1:T}$，其中$p_{\theta}(\mathbf{x}_{0:T})$就是我们熟悉的反向过程，只不过它是以概率计算的形式表达：</p>
<script type="math/tex; mode=display">
p_{\theta}(\mathbf{x}_{0:T})=p(\mathbf{x}_T)\prod_{t-1}^Tp_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t})</script><script type="math/tex; mode=display">
p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t}) = \mathcal{N}(\mathbf{x}_{t-1};\mu_{\theta}(\mathbf{x}_{t}, t), \Sigma_\theta(\mathbf{x}_{t}, t))</script><p>我们上一节里见到的优化目标，是让去噪声操作$p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t})$和加噪声操作的逆操作$q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0)$尽可能相似。然而，这个描述并不确切。扩散模型原本的目标，是最大化$p_{\theta}(\mathbf{x}_0)$这个概率，其中$\mathbf{x}_0$是来自训练集的数据。换个角度说，给定一个训练集的数据$\mathbf{x}_0$，经过前向过程和反向过程，扩散模型要让复原出$\mathbf{x}_0$的概率尽可能大。这也是我们在本文开头认识VAE时见到的优化目标。</p>
<p>最大化$p_{\theta}(\mathbf{x}_0)$，一般会写成最小化其负对数值，即最小化$-log  p_{\theta}(\mathbf{x}_0)$。使用和VAE类似的变分推理，可以把优化目标转换成优化一个叫做变分下界(variational lower bound, VLB)的量。它最终可以写成：</p>
<script type="math/tex; mode=display">
L_{VLB}=\mathbb{E}[D_{KL}(q(\mathbf{x}_T|\mathbf{x}_0) || p_\theta(\mathbf{x}_T))+\sum_{t=2}^{T}D_{KL}(q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) || p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t})) - logp_\theta(\mathbf{x}_{0}|\mathbf{x}_{1})]</script><blockquote>
<p>这里的$D_{KL}(P||Q)$表示分布P和Q之间的KL散度。KL散度是衡量两个分布相似度的指标。如果$P, Q$都是正态分布，则它们的KL散度可以由一个简单的公式给出。关于KL散度的知识可以参见我之前的文章：从零理解熵、交叉熵、KL散度。</p>
</blockquote>
<p>其中，第一项$D_{KL}(q(\mathbf{x}_T|\mathbf{x}_0) || p_\theta(\mathbf{x}_T))$和可学习参数$\theta$无关（因为可学习参数只描述了每一步去噪声操作，也就是只描述了$p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t})$），可以不去管它。那么这个优化目标就由两部分组成：</p>
<ol>
<li>最小化$D_{KL}(q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) || p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t}))$表示的是最大化每一个去噪声操作和加噪声逆操作的相似度。</li>
<li>最小化$- logp_\theta(\mathbf{x}_{0}|\mathbf{x}_{1})$就是已知$\mathbf{x}_{1}$时，让最后复原原图$\mathbf{x}_{0}$概率更高。</li>
</ol>
<p>我们分别看这两部分是怎么计算的。</p>
<p>对于第一部分，我们先回顾一下正态分布之间的KL散度公式。设一维正态分布$P, Q$的公式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(x) = \frac{1}{\sqrt{2\pi}\sigma_1}exp(-\frac{(x - \mu_1)^2}{2\sigma_1^2}) \\
Q(x) = \frac{1}{\sqrt{2\pi}\sigma_2}exp(-\frac{(x - \mu_2)^2}{2\sigma_2^2})
\end{aligned}</script><p>则</p>
<script type="math/tex; mode=display">
D_{KL}(P||Q) = log\frac{\sigma_2}{\sigma_1} + \frac{\sigma_1^2+(\mu_1-\mu_2)^2}{2\sigma_2^2} - \frac{1}{2}</script><p>而对于$D_{KL}(q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) || p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t}))$，根据前文的分析，我们知道，待求方差$\Sigma_\theta(\mathbf{x}_{t}, t)$可以直接由计算得到。</p>
<script type="math/tex; mode=display">
\Sigma_\theta(\mathbf{x}_{t}, t) = \tilde{\beta}_t\mathbf{I}=\frac{1-\bar{\alpha}_{t-1}}{1 - \bar{\alpha}_{t}} \cdot \beta_t\mathbf{I}</script><p>两个正态分布方差的比值是常量。所以，在计算KL散度时，不用管方差那一项了，只需要管均值那一项。</p>
<script type="math/tex; mode=display">
D_{KL}(q(\mathbf{x}_{t-1} | \mathbf{x}_{t}, \mathbf{x}_0) || p_\theta(\mathbf{x}_{t-1}|\mathbf{x}_{t}))\to\frac{1}{2\tilde{\beta}_t^2}||\mu_{\theta}(\mathbf{x}_{t}, t)-\tilde{\mu}_{t}(\mathbf{x}_{t}, t)||^2</script><p>由根据之前的均值公式</p>
<script type="math/tex; mode=display">
\tilde{\mu}_t(\mathbf{x}_{t}, t) = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_t)</script><script type="math/tex; mode=display">
\mu_{\theta}(\mathbf{x}_{t}, t) = \frac{1}{\sqrt{\alpha_t}}(\mathbf{x}_t -\frac{1 - \alpha_t}{\sqrt{1-\bar{\alpha}_t}}\epsilon_\theta(\mathbf{x}_{t}, t))
\\</script><p>这一部分的优化目标可以化简成</p>
<script type="math/tex; mode=display">
\frac{(1 - \alpha_t)^2}{2\alpha_t(1-\bar{\alpha}_t)\tilde{\beta}_t^2}||\epsilon_t-\epsilon_{\theta}(\mathbf{x}_{t}, t)||^2</script><p>DDPM论文指出，如果把前面的系数全部丢掉的话，模型的效果更好。最终，我们就能得到一个非常简单的优化目标：</p>
<script type="math/tex; mode=display">
||\epsilon_t-\epsilon_{\theta}(\mathbf{x}_{t}, t)||^2</script><p>这就是我们上一节见到的优化目标。</p>
<p>当然，还没完，别忘了优化目标里还有$- logp_\theta(\mathbf{x}_{0}|\mathbf{x}_{1})$这一项。它的形式为：</p>
<script type="math/tex; mode=display">
- logp_\theta(\mathbf{x}_{0}|\mathbf{x}_{1})=-log\frac{1}{\sqrt{2\pi}\tilde{\beta}_1^2}+\frac{||\mathbf{x}_{0} - \mu_{\theta}(\mathbf{x}_{1}, 1)||^2}{2\tilde{\beta}_1^2}</script><p>只管后面有$\theta$的那一项（注意，$\alpha_1=\bar{\alpha}_1=1-\beta_1$）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{(\mathbf{x}_{0} - \mu_{\theta}(\mathbf{x}_{1}, 1))^2}{2\tilde{\beta}_1^2} &= \frac{1}{2\tilde{\beta}_1^2}||\mathbf{x}_{0}-\frac{1}{\sqrt{\alpha_1}}(\mathbf{x}_1 -\frac{1 - \alpha_1}{\sqrt{1-\bar{\alpha}_1}}\epsilon_\theta(\mathbf{x}_{1}, 1))||^2 \\
&=\frac{1}{2\tilde{\beta}_1^2}||\mathbf{x}_{0}-\frac{1}{\sqrt{\alpha_1}}(\sqrt{\bar{\alpha}_1}\mathbf{x}_{0}+ \sqrt{1-\bar{\alpha}_1}\epsilon_1-\frac{1 - \alpha_1}{\sqrt{1-\bar{\alpha}_1}}\epsilon_\theta(\mathbf{x}_{1}, 1))||^2 \\
&=\frac{1}{2\tilde{\beta}_1^2\alpha_1}|| \sqrt{1-\bar{\alpha}_1}\epsilon_1-\frac{1 - \alpha_1}{\sqrt{1-\bar{\alpha}_1}}\epsilon_\theta(\mathbf{x}_{1}, 1)||^2 \\
&=\frac{1-\bar{\alpha}_1}{2\tilde{\beta}_1^2\alpha_1}|| \epsilon_1-\epsilon_\theta(\mathbf{x}_{1}, 1)||^2 \\
\end{aligned}</script><p>这和那些KL散度项$t=1$时的形式相同，我们可以用相同的方式简化优化目标，只保留$|| \epsilon_1-\epsilon_\theta(\mathbf{x}_{1}, 1)||^2$。这样，损失函数的形式全都是$||\epsilon_t-\epsilon_{\theta}(\mathbf{x}_{t}, t)||^2$了。</p>
<blockquote>
<p>DDPM论文里写$- logp_\theta(\mathbf{x}_{0}|\mathbf{x}_{1})$这一项可以直接满足简化后的公式$t=1$时的情况，而没有去掉系数的过程。我在网上没找到文章解释这一点，只好按自己的理解来推导这个误差项了。不论如何，推导的过程不是那么重要，重要的是最后的简化形式。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>图像生成任务就是把随机生成的向量（噪声）映射成和训练图像类似的图像。为此，扩散模型把这个过程看成是对纯噪声图像的去噪过程。通过学习把图像逐步变成纯噪声的逆操作，扩散模型可以把任何一个纯噪声图像变成有意义的图像，也就是完成图像生成。</p>
<p>对于不同程度的读者，应该对本文有不同的认识。</p>
<p>对于只想了解扩散模型大概原理的读者，只需要阅读第一节，并大概了解：</p>
<ul>
<li>图像生成任务的通常做法</li>
<li>图像生成任务需要监督</li>
<li>VAE通过把图像编码再解码来训练一个解码器</li>
<li>扩散模型是一类特殊的VAE，它的编码固定为加噪声，解码固定为去噪声</li>
</ul>
<p>对于想认真学习扩散模型的读者，只需读懂第二节的主要内容：</p>
<ul>
<li>扩散模型的优化目标：让反向过程尽可能成为正向过程的逆操作</li>
<li>正向过程的公式</li>
<li>反向过程的做法（采样算法）</li>
<li>加噪声逆操作的均值和方差在给定$\mathbf{x}_{0}$时可以求出来的，加噪声逆操作的均值就是去噪声的学习目标</li>
<li>简化后的损失函数与训练算法</li>
</ul>
<p>对有学有余力对数学感兴趣的读者，可以看一看第三节的内容：</p>
<ul>
<li>加噪声逆操作均值和方差的推导</li>
<li>扩散模型最早的优化目标与DDPM论文是如何简化优化目标的</li>
</ul>
<p>我个人认为，由于扩散模型的优化目标已经被大幅度简化，除非你的研究目标是改进扩散模型本身，否则没必要花过多的时间钻研数学原理。在学习时，建议快点看懂扩散模型的整体思想，搞懂最核心的训练算法和采样算法，跑通代码。之后就可以去看较新的论文了。</p>
<p>在附录中，我给出了一份DDPM的简单实现。欢迎大家参考，并自己动手复现一遍DDPM。</p>
<h2 id="参考资料与学习建议"><a href="#参考资料与学习建议" class="headerlink" title="参考资料与学习建议"></a>参考资料与学习建议</h2><p>网上绝大多数的中英文教程都是照搬 <a target="_blank" rel="noopener" href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">https://lilianweng.github.io/posts/2021-07-11-diffusion-models/</a> 这篇文章的。这篇文章像教科书一样严谨，适合有一定数学基础的人阅读，但不适合给初学者学习。建议在弄懂扩散模型的大概原理后再来阅读这篇文章补充细节。</p>
<p>多数介绍扩散模型的文章对没学过相关数学知识的人来说很不友好，我在阅读此类文章时碰到了大量的问题：为什么前向公式里有个$\sqrt{1-\beta}$？为什么突然冒出一个快速算$\mathbf{x}_{t}$的公式？为什么反向过程里来了个贝叶斯公式？优化目标是什么？$-log  p_{\theta}(\mathbf{x}_0)$是什么？为什么优化目标里一大堆项，每一项的意义又是什么？为什么最后莫名其妙算一个$\epsilon$？为什么采样时$t=0$就不用加方差项了？好不容易，我才把这些问题慢慢搞懂，并在本文做出了解释。希望我的解答能够帮助到同样有这些困惑的读者。想逐步学习扩散模型，可以先看懂我这篇文章的大概讲解，再去其他文章里学懂一些细节。无论是教，还是学，最重要的都是搞懂整体思路，知道动机，最后再去强调细节。</p>
<p>再强烈推荐一位作者写的DDPM系列介绍：<a target="_blank" rel="noopener" href="https://kexue.fm/archives/9119">https://kexue.fm/archives/9119</a> 。这位作者是全网为数不多的能令我敬佩的作者。早知道有这些文章，我也没必要自己写一遍了。</p>
<p>这里还有篇文章给出了扩散模型中数学公式的详细推导，并补充了变分推理的背景介绍，适合从头学起：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2208.11970">https://arxiv.org/abs/2208.11970</a></p>
<p>想深入学习DDPM，可以看一看最重要的两篇论文：<em>Deep Unsupervised Learning using Nonequilibrium Thermodynamics</em>、<em>Denoising Diffusion Probabilistic Models</em>。当然，后者更重要一些，里面的一些实验结果仍有阅读价值。</p>
<p>我在代码复现时参考了<a target="_blank" rel="noopener" href="https://medium.com/mlearning-ai/enerating-images-with-ddpms-a-pytorch-implementation-cef5a2ba8cb1">这篇文章</a>。相对于网上的其他开源DDPM实现，这份代码比较简短易懂，更适合学习。不过，这份代码有一点问题。它的神经网络不够强大，采样结果会有一点问题。</p>
<h2 id="附录：代码复现"><a href="#附录：代码复现" class="headerlink" title="附录：代码复现"></a>附录：代码复现</h2><p>在这个项目中，我们要用PyTorch实现一个基于U-Net的DDPM，并在MNIST数据集（经典的手写数字数据集）上训练它。模型几分钟就能训练完，我们可以方便地做各种各样的实验。</p>
<p>后续讲解只会给出代码片段，完整的代码请参见 <a target="_blank" rel="noopener" href="https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/ddpm">https://github.com/SingleZombie/DL-Demos/tree/master/dldemos/ddpm</a> 。git clone 仓库并安装后，可以直接运行目录里的<code>main.py</code>训练模型并采样。</p>
<h3 id="获取数据集"><a href="#获取数据集" class="headerlink" title="获取数据集"></a>获取数据集</h3><p>PyTorch的<code>torchvision</code>提供了获取了MNIST的接口，我们只需要用下面的函数就可以生成MNIST的<code>Dataset</code>实例。参数中，<code>root</code>为数据集的下载路径，<code>download</code>为是否自动下载数据集。令<code>download=True</code>的话，第一次调用该函数时会自动下载数据集，而第二次之后就不用下载了，函数会读取存储在<code>root</code>里的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mnist = torchvision.datasets.MNIST(root=<span class="string">&#x27;data/mnist&#x27;</span>, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以用下面的代码来下载MNIST并输出该数据集的一些信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> ToTensor</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_dataset</span>():</span></span><br><span class="line">    mnist = torchvision.datasets.MNIST(root=<span class="string">&#x27;data/mnist&#x27;</span>, download=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;length of MNIST&#x27;</span>, <span class="built_in">len</span>(mnist))</span><br><span class="line">    <span class="built_in">id</span> = <span class="number">4</span></span><br><span class="line">    img, label = mnist[<span class="built_in">id</span>]</span><br><span class="line">    <span class="built_in">print</span>(img)</span><br><span class="line">    <span class="built_in">print</span>(label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># On computer with monitor</span></span><br><span class="line">    <span class="comment"># img.show()</span></span><br><span class="line"></span><br><span class="line">    img.save(<span class="string">&#x27;work_dirs/tmp.jpg&#x27;</span>)</span><br><span class="line">    tensor = ToTensor()(img)</span><br><span class="line">    <span class="built_in">print</span>(tensor.shape)</span><br><span class="line">    <span class="built_in">print</span>(tensor.<span class="built_in">max</span>())</span><br><span class="line">    <span class="built_in">print</span>(tensor.<span class="built_in">min</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    download_dataset()</span><br></pre></td></tr></table></figure><br>执行这段代码，输出大致为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">length of MNIST 60000</span><br><span class="line">&lt;PIL.Image.Image image mode=L size=28x28 at 0x7FB3F09CCE50&gt;</span><br><span class="line">9</span><br><span class="line">torch.Size([1, 28, 28])</span><br><span class="line">tensor(1.)</span><br><span class="line">tensor(0.)</span><br></pre></td></tr></table></figure>
<p>第一行输出表明，MNIST数据集里有60000张图片。而从第二行和第三行输出中，我们发现每一项数据由图片和标签组成，图片是大小为<code>28x28</code>的PIL格式的图片，标签表明该图片是哪个数字。我们可以用<code>torchvision</code>里的<code>ToTensor()</code>把PIL图片转成PyTorch张量，进一步查看图片的信息。最后三行输出表明，每一张图片都是单通道图片（灰度图），颜色值的取值范围是0~1。</p>
<p>我们可以查看一下每张图片的样子。如果你是在用带显示器的电脑，可以去掉<code>img.show</code>那一行的注释，直接查看图片；如果你是在用服务器，可以去<code>img.save</code>的路径里查看图片。该图片的应该长这个样子：</p>
<p><img src="/2023/07/07/20230330-diffusion-model/c1.jpg" alt></p>
<p>我们可以用下面的代码预处理数据并创建<code>DataLoader</code>。由于DDPM会把图像和正态分布关联起来，我们更希望图像颜色值的取值范围是<code>[-1, 1]</code>。为此，我们可以对图像做一个线性变换，减0.5再乘2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataloader</span>(<span class="params">batch_size: <span class="built_in">int</span></span>):</span></span><br><span class="line">    transform = Compose([ToTensor(), Lambda(<span class="keyword">lambda</span> x: (x - <span class="number">0.5</span>) * <span class="number">2</span>)])</span><br><span class="line">    dataset = torchvision.datasets.MNIST(root=<span class="string">&#x27;data/mnist&#x27;</span>,</span><br><span class="line">                                         transform=transform)</span><br><span class="line">    <span class="keyword">return</span> DataLoader(dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DDPM-类"><a href="#DDPM-类" class="headerlink" title="DDPM 类"></a>DDPM 类</h3><p>在代码中，我们要实现一个<code>DDPM</code>类。它维护了扩散过程中的一些常量(比如$\alpha$），并且可以计算正向过程和反向过程的结果。</p>
<p>先来实现一下<code>DDPM</code>类的初始化函数。一开始，我们遵从论文的配置，用<code>torch.linspace(min_beta, max_beta, n_steps)</code>从<code>min_beta</code>到<code>max_beta</code>线性地生成<code>n_steps</code>个时刻的$\beta$。接着，我们根据公式$\alpha_t=1-\beta_t, \bar{\alpha}_t=\prod_{i=1}^t\alpha_i$，计算每个时刻的<code>alpha</code>和<code>alpha_bar</code>。注意，为了方便实现，我们让<code>t</code>的取值从0开始，要比论文里的$t$少1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDPM</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># n_steps 就是论文里的 T</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 device,</span></span></span><br><span class="line"><span class="params"><span class="function">                 n_steps: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 min_beta: <span class="built_in">float</span> = <span class="number">0.0001</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 max_beta: <span class="built_in">float</span> = <span class="number">0.02</span></span>):</span></span><br><span class="line">        betas = torch.linspace(min_beta, max_beta, n_steps).to(device)</span><br><span class="line">        alphas = <span class="number">1</span> - betas</span><br><span class="line">        alpha_bars = torch.empty_like(alphas)</span><br><span class="line">        product = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(alphas):</span><br><span class="line">            product *= alpha</span><br><span class="line">            alpha_bars[i] = product</span><br><span class="line">        self.betas = betas</span><br><span class="line">        self.n_steps = n_steps</span><br><span class="line">        self.alphas = alphas</span><br><span class="line">        self.alpha_bars = alpha_bars</span><br></pre></td></tr></table></figure>
<blockquote>
<p>部分实现会让 DDPM 继承<code>torch.nn.Module</code>，但我认为这样不好。DDPM本身不是一个神经网络，它只是描述了前向过程和后向过程的一些计算。只有涉及可学习参数的神经网络类才应该继承 <code>torch.nn.Module</code>。</p>
</blockquote>
<p>准备好了变量后，我们可以来实现<code>DDPM</code>类的其他方法。先实现正向过程方法，该方法会根据公式$\mathbf{x}_t = \sqrt{\bar{\alpha}_t}\mathbf{x}_{0} + \sqrt{1-\bar{\alpha}_t}\epsilon_t$计算正向过程中的$\mathbf{x}_t$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_forward</span>(<span class="params">self, x, t, eps=<span class="literal">None</span></span>):</span></span><br><span class="line">    alpha_bar = self.alpha_bars[t].reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> eps <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        eps = torch.randn_like(x)</span><br><span class="line">    res = eps * torch.sqrt(<span class="number">1</span> - alpha_bar) + torch.sqrt(alpha_bar) * x</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>这里要解释一些PyTorch编程上的细节。这份代码中，<code>self.alpha_bars</code>是一个一维<code>Tensor</code>。而在并行训练中，我们一般会令<code>t</code>为一个形状为<code>(batch_size, )</code>的<code>Tensor</code>。PyTorch允许我们直接用<code>self.alpha_bars[t]</code>从<code>self.alpha_bars</code>里取出<code>batch_size</code>个数，就像用一个普通的整型索引来从数组中取出一个数一样。有些实现会用<code>torch.gather</code>从<code>self.alpha_bars</code>里取数，其作用是一样的。</p>
<p>我们可以随机从训练集取图片做测试，看看它们在前向过程中是怎么逐步变成噪声的。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/c2.jpg" alt></p>
<p>接下来实现反向过程。在反向过程中，DDPM会用神经网络预测每一轮去噪的均值，把$\mathbf{x}_t$复原回$\mathbf{x}_0$，以完成图像生成。反向过程即对应论文中的采样算法。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/7.jpg" alt></p>
<p>其实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_backward</span>(<span class="params">self, img_shape, net, device, simple_var=<span class="literal">True</span></span>):</span></span><br><span class="line">    x = torch.randn(img_shape).to(device)</span><br><span class="line">    net = net.to(device)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.n_steps - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        x = self.sample_backward_step(x, t, net, simple_var)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_backward_step</span>(<span class="params">self, x_t, t, net, simple_var=<span class="literal">True</span></span>):</span></span><br><span class="line">    n = x_t.shape[<span class="number">0</span>]</span><br><span class="line">    t_tensor = torch.tensor([t] * n,</span><br><span class="line">                            dtype=torch.long).to(x_t.device).unsqueeze(<span class="number">1</span>)</span><br><span class="line">    eps = net(x_t, t_tensor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        noise = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> simple_var:</span><br><span class="line">            var = self.betas[t]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            var = (<span class="number">1</span> - self.alpha_bars[t - <span class="number">1</span>]) / (</span><br><span class="line">                <span class="number">1</span> - self.alpha_bars[t]) * self.betas[t]</span><br><span class="line">        noise = torch.randn_like(x_t)</span><br><span class="line">        noise *= torch.sqrt(var)</span><br><span class="line"></span><br><span class="line">    mean = (x_t -</span><br><span class="line">            (<span class="number">1</span> - self.alphas[t]) / torch.sqrt(<span class="number">1</span> - self.alpha_bars[t]) *</span><br><span class="line">            eps) / torch.sqrt(self.alphas[t])</span><br><span class="line">    x_t = mean + noise</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_t</span><br></pre></td></tr></table></figure>
<p>其中，<code>sample_backward</code>是用来给外部调用的方法，而<code>sample_backward_step</code>是执行一步反向过程的方法。</p>
<p><code>sample_backward</code>会随机生成纯噪声<code>x</code>（对应$\mathbf{x}_T$），再令<code>t</code>从<code>n_steps - 1</code>到<code>0</code>，调用<code>sample_backward_step</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_backward</span>(<span class="params">self, img_shape, net, device, simple_var=<span class="literal">True</span></span>):</span></span><br><span class="line">    x = torch.randn(img_shape).to(device)</span><br><span class="line">    net = net.to(device)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(self.n_steps - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        x = self.sample_backward_step(x, t, net, simple_var)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>在<code>sample_backward_step</code>中，我们先准备好这一步的神经网络输出<code>eps</code>。为此，我们要把整型的<code>t</code>转换成一个格式正确的<code>Tensor</code>。考虑到输入里可能有多个batch，我们先获取batch size <code>n</code>，再根据它来生成<code>t_tensor</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_backward_step</span>(<span class="params">self, x_t, t, net, simple_var=<span class="literal">True</span></span>):</span></span><br><span class="line"></span><br><span class="line">    n = x_t.shape[<span class="number">0</span>]</span><br><span class="line">    t_tensor = torch.tensor([t] * n,</span><br><span class="line">                            dtype=torch.long).to(x_t.device).unsqueeze(<span class="number">1</span>)</span><br><span class="line">    eps = net(x_t, t_tensor)</span><br></pre></td></tr></table></figure>
<p>之后，我们来处理反向过程公式中的方差项。根据伪代码，我们仅在<code>t</code>非零的时候算方差项。方差项用到的方差有两种取值，效果差不多，我们用<code>simple_var</code>来控制选哪种取值方式。获取方差后，我们再随机采样一个噪声，根据公式，得到方差项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">    noise = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> simple_var:</span><br><span class="line">        var = self.betas[t]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        var = (<span class="number">1</span> - self.alpha_bars[t - <span class="number">1</span>]) / (</span><br><span class="line">            <span class="number">1</span> - self.alpha_bars[t]) * self.betas[t]</span><br><span class="line">    noise = torch.randn_like(x_t)</span><br><span class="line">    noise *= torch.sqrt(var)</span><br></pre></td></tr></table></figure>
<p>最后，我们把<code>eps</code>和方差项套入公式，得到这一步更新过后的图像<code>x_t</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mean = (x_t -</span><br><span class="line">        (<span class="number">1</span> - self.alphas[t]) / torch.sqrt(<span class="number">1</span> - self.alpha_bars[t]) *</span><br><span class="line">        eps) / torch.sqrt(self.alphas[t])</span><br><span class="line">x_t = mean + noise</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x_t</span><br></pre></td></tr></table></figure>
<p>稍后完成了训练后，我们再来看反向过程的输出结果。</p>
<h3 id="训练算法"><a href="#训练算法" class="headerlink" title="训练算法"></a>训练算法</h3><p>接下来，我们先跳过神经网络的实现，直接完成论文里的训练算法。</p>
<p>再回顾一遍伪代码。首先，我们要随机选取训练图片$\mathbf{x}_{0}$，随机生成当前要训练的时刻$t$，以及随机生成一个生成$\mathbf{x}_{t}$的高斯噪声。之后，我们把$\mathbf{x}_{t}$和$t$输入进神经网络，尝试预测噪声。最后，我们以预测噪声和实际噪声的均方误差为损失函数做梯度下降。</p>
<p><img src="/2023/07/07/20230330-diffusion-model/6.jpg" alt></p>
<p>为此，我们可以用下面的代码实现训练。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> dldemos.ddpm.dataset <span class="keyword">import</span> get_dataloader, get_img_shape</span><br><span class="line"><span class="keyword">from</span> dldemos.ddpm.ddpm <span class="keyword">import</span> DDPM</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> einops</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">512</span></span><br><span class="line">n_epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">ddpm: DDPM, net, device, ckpt_path</span>):</span></span><br><span class="line">    <span class="comment"># n_steps 就是公式里的 T</span></span><br><span class="line">    <span class="comment"># net 是某个继承自 torch.nn.Module 的神经网络</span></span><br><span class="line">    n_steps = ddpm.n_steps</span><br><span class="line">    dataloader = get_dataloader(batch_size)</span><br><span class="line">    net = net.to(device)</span><br><span class="line">    loss_fn = nn.MSELoss()</span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(), <span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">        <span class="keyword">for</span> x, _ <span class="keyword">in</span> dataloader:</span><br><span class="line">            current_batch_size = x.shape[<span class="number">0</span>]</span><br><span class="line">            x = x.to(device)</span><br><span class="line">            t = torch.randint(<span class="number">0</span>, n_steps, (current_batch_size, )).to(device)</span><br><span class="line">            eps = torch.randn_like(x).to(device)</span><br><span class="line">            x_t = ddpm.sample_forward(x, t, eps)</span><br><span class="line">            eps_theta = net(x_t, t.reshape(current_batch_size, <span class="number">1</span>))</span><br><span class="line">            loss = loss_fn(eps_theta, eps)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">    torch.save(net.state_dict(), ckpt_path)</span><br></pre></td></tr></table></figure>
<p>代码的主要逻辑都在循环里。首先是完成训练数据$\mathbf{x}_{0}$、$t$、噪声的采样。采样$\mathbf{x}_{0}$的工作可以交给PyTorch的DataLoader完成，每轮遍历得到的<code>x</code>就是训练数据。$t$的采样可以用<code>torch.randint</code>函数随机从<code>[0, n_steps - 1]</code>取数。采样高斯噪声可以直接用<code>torch.randn_like(x)</code>生成一个和训练图片<code>x</code>形状一样的符合标准正态分布的图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, _ <span class="keyword">in</span> dataloader:</span><br><span class="line">    current_batch_size = x.shape[<span class="number">0</span>]</span><br><span class="line">    x = x.to(device)</span><br><span class="line">    t = torch.randint(<span class="number">0</span>, n_steps, (current_batch_size, )).to(device)</span><br><span class="line">    eps = torch.randn_like(x).to(device)</span><br></pre></td></tr></table></figure>
<p>之后计算$\mathbf{x}_{t}$并将其和$t$输入进神经网络<code>net</code>。计算$\mathbf{x}_{t}$的任务会由<code>DDPM</code>类的<code>sample_forward</code>方法完成，我们在上文已经实现了它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_t = ddpm.sample_forward(x, t, eps)</span><br><span class="line">eps_theta = net(x_t, t.reshape(current_batch_size, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>得到了预测的噪声<code>eps_theta</code>，我们调用PyTorch的API，算均方误差并调用优化器即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">loss_fn = nn.MSELoss()</span><br><span class="line">optimizer = torch.optim.Adam(net.parameters(), <span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        loss = loss_fn(eps_theta, eps)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure></p>
<h3 id="去噪神经网络"><a href="#去噪神经网络" class="headerlink" title="去噪神经网络"></a>去噪神经网络</h3><p>在DDPM中，理论上我们可以用任意一种神经网络架构。但由于DDPM任务十分接近图像去噪任务，而U-Net又是去噪任务中最常见的网络架构，因此绝大多数DDPM都会使用基于U-Net的神经网络。</p>
<p>我一直想训练一个尽可能简单的模型。经过多次实验，我发现DDPM的神经网络很难训练。哪怕是对于比较简单的MNIST数据集，结构差一点的网络（比如纯ResNet）都不太行，只有带了残差块和时序编码的U-Net才能较好地完成去噪。注意力模块倒是可以不用加上。</p>
<p>由于神经网络结构并不是DDPM学习的重点，我这里就不对U-Net的写法做解说，而是直接贴上代码了。代码中大部分内容都和普通的U-Net无异。唯一要注意的地方就是时序编码。去噪网络的输入除了图像外，还有一个时间戳<code>t</code>。我们要考虑怎么把<code>t</code>的信息和输入图像信息融合起来。大部分人的做法是对<code>t</code>进行Transformer中的位置编码，把该编码加到图像的每一处上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> dldemos.ddpm.dataset <span class="keyword">import</span> get_img_shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PositionalEncoding</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, max_seq_len: <span class="built_in">int</span>, d_model: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Assume d_model is an even number for convenience</span></span><br><span class="line">        <span class="keyword">assert</span> d_model % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        pe = torch.zeros(max_seq_len, d_model)</span><br><span class="line">        i_seq = torch.linspace(<span class="number">0</span>, max_seq_len - <span class="number">1</span>, max_seq_len)</span><br><span class="line">        j_seq = torch.linspace(<span class="number">0</span>, d_model - <span class="number">2</span>, d_model // <span class="number">2</span>)</span><br><span class="line">        pos, two_i = torch.meshgrid(i_seq, j_seq)</span><br><span class="line">        pe_2i = torch.sin(pos / <span class="number">10000</span>**(two_i / d_model))</span><br><span class="line">        pe_2i_1 = torch.cos(pos / <span class="number">10000</span>**(two_i / d_model))</span><br><span class="line">        pe = torch.stack((pe_2i, pe_2i_1), <span class="number">2</span>).reshape(max_seq_len, d_model)</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(max_seq_len, d_model)</span><br><span class="line">        self.embedding.weight.data = pe</span><br><span class="line">        self.embedding.requires_grad_(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, t</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.embedding(t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResidualBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_c: <span class="built_in">int</span>, out_c: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_c, out_c, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(out_c)</span><br><span class="line">        self.actvation1 = nn.ReLU()</span><br><span class="line">        self.conv2 = nn.Conv2d(out_c, out_c, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(out_c)</span><br><span class="line">        self.actvation2 = nn.ReLU()</span><br><span class="line">        <span class="keyword">if</span> in_c != out_c:</span><br><span class="line">            self.shortcut = nn.Sequential(nn.Conv2d(in_c, out_c, <span class="number">1</span>),</span><br><span class="line">                                          nn.BatchNorm2d(out_c))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.shortcut = nn.Identity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        x = self.conv1(<span class="built_in">input</span>)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.actvation1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.bn2(x)</span><br><span class="line">        x += self.shortcut(<span class="built_in">input</span>)</span><br><span class="line">        x = self.actvation2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 n_steps,</span></span></span><br><span class="line"><span class="params"><span class="function">                 intermediate_channels=[<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                 pe_dim=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 insert_t_to_all_layers=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        C, H, W = get_img_shape()  <span class="comment"># 1, 28, 28</span></span><br><span class="line">        self.pe = PositionalEncoding(n_steps, pe_dim)</span><br><span class="line"></span><br><span class="line">        self.pe_linears = nn.ModuleList()</span><br><span class="line">        self.all_t = insert_t_to_all_layers</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> insert_t_to_all_layers:</span><br><span class="line">            self.pe_linears.append(nn.Linear(pe_dim, C))</span><br><span class="line"></span><br><span class="line">        self.residual_blocks = nn.ModuleList()</span><br><span class="line">        prev_channel = C</span><br><span class="line">        <span class="keyword">for</span> channel <span class="keyword">in</span> intermediate_channels:</span><br><span class="line">            self.residual_blocks.append(ResidualBlock(prev_channel, channel))</span><br><span class="line">            <span class="keyword">if</span> insert_t_to_all_layers:</span><br><span class="line">                self.pe_linears.append(nn.Linear(pe_dim, prev_channel))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.pe_linears.append(<span class="literal">None</span>)</span><br><span class="line">            prev_channel = channel</span><br><span class="line">        self.output_layer = nn.Conv2d(prev_channel, C, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, t</span>):</span></span><br><span class="line">        n = t.shape[<span class="number">0</span>]</span><br><span class="line">        t = self.pe(t)</span><br><span class="line">        <span class="keyword">for</span> m_x, m_t <span class="keyword">in</span> <span class="built_in">zip</span>(self.residual_blocks, self.pe_linears):</span><br><span class="line">            <span class="keyword">if</span> m_t <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                pe = m_t(t).reshape(n, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">                x = x + pe</span><br><span class="line">            x = m_x(x)</span><br><span class="line">        x = self.output_layer(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnetBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, shape, in_c, out_c, residual=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.ln = nn.LayerNorm(shape)</span><br><span class="line">        self.conv1 = nn.Conv2d(in_c, out_c, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(out_c, out_c, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.activation = nn.ReLU()</span><br><span class="line">        self.residual = residual</span><br><span class="line">        <span class="keyword">if</span> residual:</span><br><span class="line">            <span class="keyword">if</span> in_c == out_c:</span><br><span class="line">                self.residual_conv = nn.Identity()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.residual_conv = nn.Conv2d(in_c, out_c, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.ln(x)</span><br><span class="line">        out = self.conv1(out)</span><br><span class="line">        out = self.activation(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        <span class="keyword">if</span> self.residual:</span><br><span class="line">            out += self.residual_conv(x)</span><br><span class="line">        out = self.activation(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">                 n_steps,</span></span></span><br><span class="line"><span class="params"><span class="function">                 channels=[<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                 pe_dim=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 residual=<span class="literal">False</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        C, H, W = get_img_shape()</span><br><span class="line">        layers = <span class="built_in">len</span>(channels)</span><br><span class="line">        Hs = [H]</span><br><span class="line">        Ws = [W]</span><br><span class="line">        cH = H</span><br><span class="line">        cW = W</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(layers - <span class="number">1</span>):</span><br><span class="line">            cH //= <span class="number">2</span></span><br><span class="line">            cW //= <span class="number">2</span></span><br><span class="line">            Hs.append(cH)</span><br><span class="line">            Ws.append(cW)</span><br><span class="line"></span><br><span class="line">        self.pe = PositionalEncoding(n_steps, pe_dim)</span><br><span class="line"></span><br><span class="line">        self.encoders = nn.ModuleList()</span><br><span class="line">        self.decoders = nn.ModuleList()</span><br><span class="line">        self.pe_linears_en = nn.ModuleList()</span><br><span class="line">        self.pe_linears_de = nn.ModuleList()</span><br><span class="line">        self.downs = nn.ModuleList()</span><br><span class="line">        self.ups = nn.ModuleList()</span><br><span class="line">        prev_channel = C</span><br><span class="line">        <span class="keyword">for</span> channel, cH, cW <span class="keyword">in</span> <span class="built_in">zip</span>(channels[<span class="number">0</span>:-<span class="number">1</span>], Hs[<span class="number">0</span>:-<span class="number">1</span>], Ws[<span class="number">0</span>:-<span class="number">1</span>]):</span><br><span class="line">            self.pe_linears_en.append(</span><br><span class="line">                nn.Sequential(nn.Linear(pe_dim, prev_channel), nn.ReLU(),</span><br><span class="line">                              nn.Linear(prev_channel, prev_channel)))</span><br><span class="line">            self.encoders.append(</span><br><span class="line">                nn.Sequential(</span><br><span class="line">                    UnetBlock((prev_channel, cH, cW),</span><br><span class="line">                              prev_channel,</span><br><span class="line">                              channel,</span><br><span class="line">                              residual=residual),</span><br><span class="line">                    UnetBlock((channel, cH, cW),</span><br><span class="line">                              channel,</span><br><span class="line">                              channel,</span><br><span class="line">                              residual=residual)))</span><br><span class="line">            self.downs.append(nn.Conv2d(channel, channel, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">            prev_channel = channel</span><br><span class="line"></span><br><span class="line">        self.pe_mid = nn.Linear(pe_dim, prev_channel)</span><br><span class="line">        channel = channels[-<span class="number">1</span>]</span><br><span class="line">        self.mid = nn.Sequential(</span><br><span class="line">            UnetBlock((prev_channel, Hs[-<span class="number">1</span>], Ws[-<span class="number">1</span>]),</span><br><span class="line">                      prev_channel,</span><br><span class="line">                      channel,</span><br><span class="line">                      residual=residual),</span><br><span class="line">            UnetBlock((channel, Hs[-<span class="number">1</span>], Ws[-<span class="number">1</span>]),</span><br><span class="line">                      channel,</span><br><span class="line">                      channel,</span><br><span class="line">                      residual=residual),</span><br><span class="line">        )</span><br><span class="line">        prev_channel = channel</span><br><span class="line">        <span class="keyword">for</span> channel, cH, cW <span class="keyword">in</span> <span class="built_in">zip</span>(channels[-<span class="number">2</span>::-<span class="number">1</span>], Hs[-<span class="number">2</span>::-<span class="number">1</span>], Ws[-<span class="number">2</span>::-<span class="number">1</span>]):</span><br><span class="line">            self.pe_linears_de.append(nn.Linear(pe_dim, prev_channel))</span><br><span class="line">            self.ups.append(nn.ConvTranspose2d(prev_channel, channel, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">            self.decoders.append(</span><br><span class="line">                nn.Sequential(</span><br><span class="line">                    UnetBlock((channel * <span class="number">2</span>, cH, cW),</span><br><span class="line">                              channel * <span class="number">2</span>,</span><br><span class="line">                              channel,</span><br><span class="line">                              residual=residual),</span><br><span class="line">                    UnetBlock((channel, cH, cW),</span><br><span class="line">                              channel,</span><br><span class="line">                              channel,</span><br><span class="line">                              residual=residual)))</span><br><span class="line"></span><br><span class="line">            prev_channel = channel</span><br><span class="line"></span><br><span class="line">        self.conv_out = nn.Conv2d(prev_channel, C, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, t</span>):</span></span><br><span class="line">        n = t.shape[<span class="number">0</span>]</span><br><span class="line">        t = self.pe(t)</span><br><span class="line">        encoder_outs = []</span><br><span class="line">        <span class="keyword">for</span> pe_linear, encoder, down <span class="keyword">in</span> <span class="built_in">zip</span>(self.pe_linears_en, self.encoders,</span><br><span class="line">                                            self.downs):</span><br><span class="line">            pe = pe_linear(t).reshape(n, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            x = encoder(x + pe)</span><br><span class="line">            encoder_outs.append(x)</span><br><span class="line">            x = down(x)</span><br><span class="line">        pe = self.pe_mid(t).reshape(n, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        x = self.mid(x + pe)</span><br><span class="line">        <span class="keyword">for</span> pe_linear, decoder, up, encoder_out <span class="keyword">in</span> <span class="built_in">zip</span>(self.pe_linears_de,</span><br><span class="line">                                                       self.decoders, self.ups,</span><br><span class="line">                                                       encoder_outs[::-<span class="number">1</span>]):</span><br><span class="line">            pe = pe_linear(t).reshape(n, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">            x = up(x)</span><br><span class="line"></span><br><span class="line">            pad_x = encoder_out.shape[<span class="number">2</span>] - x.shape[<span class="number">2</span>]</span><br><span class="line">            pad_y = encoder_out.shape[<span class="number">3</span>] - x.shape[<span class="number">3</span>]</span><br><span class="line">            x = F.pad(x, (pad_x // <span class="number">2</span>, pad_x - pad_x // <span class="number">2</span>, pad_y // <span class="number">2</span>,</span><br><span class="line">                          pad_y - pad_y // <span class="number">2</span>))</span><br><span class="line">            x = torch.cat((encoder_out, x), dim=<span class="number">1</span>)</span><br><span class="line">            x = decoder(x + pe)</span><br><span class="line">        x = self.conv_out(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">convnet_small_cfg = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ConvNet&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;intermediate_channels&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">    <span class="string">&#x27;pe_dim&#x27;</span>: <span class="number">128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convnet_medium_cfg = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ConvNet&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;intermediate_channels&#x27;</span>: [<span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;pe_dim&#x27;</span>: <span class="number">256</span>,</span><br><span class="line">    <span class="string">&#x27;insert_t_to_all_layers&#x27;</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line">convnet_big_cfg = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;ConvNet&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;intermediate_channels&#x27;</span>: [<span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">160</span>, <span class="number">160</span>],</span><br><span class="line">    <span class="string">&#x27;pe_dim&#x27;</span>: <span class="number">256</span>,</span><br><span class="line">    <span class="string">&#x27;insert_t_to_all_layers&#x27;</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unet_1_cfg = &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;UNet&#x27;</span>, <span class="string">&#x27;channels&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>], <span class="string">&#x27;pe_dim&#x27;</span>: <span class="number">128</span>&#125;</span><br><span class="line">unet_res_cfg = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;UNet&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;channels&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;pe_dim&#x27;</span>: <span class="number">128</span>,</span><br><span class="line">    <span class="string">&#x27;residual&#x27;</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_network</span>(<span class="params">config: <span class="built_in">dict</span>, n_steps</span>):</span></span><br><span class="line">    network_type = config.pop(<span class="string">&#x27;type&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> network_type == <span class="string">&#x27;ConvNet&#x27;</span>:</span><br><span class="line">        network_cls = ConvNet</span><br><span class="line">    <span class="keyword">elif</span> network_type == <span class="string">&#x27;UNet&#x27;</span>:</span><br><span class="line">        network_cls = UNet</span><br><span class="line"></span><br><span class="line">    network = network_cls(n_steps, **config)</span><br><span class="line">    <span class="keyword">return</span> network</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实验结果与采样"><a href="#实验结果与采样" class="headerlink" title="实验结果与采样"></a>实验结果与采样</h3><p>把之前的所有代码综合一下，我们以带残差块的U-Net为去噪网络，执行训练。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n_steps = <span class="number">1000</span></span><br><span class="line">    config_id = <span class="number">4</span></span><br><span class="line">    device = <span class="string">&#x27;cuda&#x27;</span></span><br><span class="line">    model_path = <span class="string">&#x27;dldemos/ddpm/model_unet_res.pth&#x27;</span></span><br><span class="line"></span><br><span class="line">    config = unet_res_cfg</span><br><span class="line">    net = build_network(config, n_steps)</span><br><span class="line">    ddpm = DDPM(device, n_steps)</span><br><span class="line"></span><br><span class="line">    train(ddpm, net, device=device, ckpt_path=model_path)</span><br></pre></td></tr></table></figure></p>
<p>按照默认训练配置，在3090上花5分钟不到，训练30~40个epoch即可让网络基本收敛。最终收敛时loss在0.023~0.024左右。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">batch size: 512</span><br><span class="line">epoch 0 loss: 0.23103461712201437 elapsed 7.01s</span><br><span class="line">epoch 1 loss: 0.0627968365987142 elapsed 13.66s</span><br><span class="line">epoch 2 loss: 0.04828845852613449 elapsed 20.25s</span><br><span class="line">epoch 3 loss: 0.04148937337398529 elapsed 26.80s</span><br><span class="line">epoch 4 loss: 0.03801360730528831 elapsed 33.37s</span><br><span class="line">epoch 5 loss: 0.03604260584712028 elapsed 39.96s</span><br><span class="line">epoch 6 loss: 0.03357676289876302 elapsed 46.57s</span><br><span class="line">epoch 7 loss: 0.0335664684087038 elapsed 53.15s</span><br><span class="line">...</span><br><span class="line">epoch 30 loss: 0.026149748386939366 elapsed 204.64s</span><br><span class="line">epoch 31 loss: 0.025854381563266117 elapsed 211.24s</span><br><span class="line">epoch 32 loss: 0.02589433005253474 elapsed 217.84s</span><br><span class="line">epoch 33 loss: 0.026276464049021404 elapsed 224.41s</span><br><span class="line">...</span><br><span class="line">epoch 96 loss: 0.023299352884292603 elapsed 640.25s</span><br><span class="line">epoch 97 loss: 0.023460942271351815 elapsed 646.90s</span><br><span class="line">epoch 98 loss: 0.023584651704629263 elapsed 653.54s</span><br><span class="line">epoch 99 loss: 0.02364126600921154 elapsed 660.22s</span><br></pre></td></tr></table></figure>
<p>训练这个网络时，并没有特别好的测试指标，我们只能通过观察采样图像来评价网络的表现。我们可以用下面的代码调用DDPM的反向传播方法，生成多幅图像并保存下来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_imgs</span>(<span class="params">ddpm,</span></span></span><br><span class="line"><span class="params"><span class="function">                net,</span></span></span><br><span class="line"><span class="params"><span class="function">                output_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                n_sample=<span class="number">81</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                device=<span class="string">&#x27;cuda&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                simple_var=<span class="literal">True</span></span>):</span></span><br><span class="line">    net = net.to(device)</span><br><span class="line">    net = net.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        shape = (n_sample, *get_img_shape())  <span class="comment"># 1, 3, 28, 28</span></span><br><span class="line">        imgs = ddpm.sample_backward(shape,</span><br><span class="line">                                    net,</span><br><span class="line">                                    device=device,</span><br><span class="line">                                    simple_var=simple_var).detach().cpu()</span><br><span class="line">        imgs = (imgs + <span class="number">1</span>) / <span class="number">2</span> * <span class="number">255</span></span><br><span class="line">        imgs = imgs.clamp(<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">        imgs = einops.rearrange(imgs,</span><br><span class="line">                                <span class="string">&#x27;(b1 b2) c h w -&gt; (b1 h) (b2 w) c&#x27;</span>,</span><br><span class="line">                                b1=<span class="built_in">int</span>(n_sample**<span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">        imgs = imgs.numpy().astype(np.uint8)</span><br><span class="line"></span><br><span class="line">        cv2.imwrite(output_path, imgs)</span><br></pre></td></tr></table></figure>
<p>一切顺利的话，我们可以得到一些不错的生成结果。下图是我得到的一些生成图片：</p>
<p><img src="/2023/07/07/20230330-diffusion-model/c3.jpg" alt></p>
<p>大部分生成的图片都对应一个阿拉伯数字，它们和训练集MNIST里的图片非常接近。这算是一个不错的生成结果。</p>
<p>如果神经网络的拟合能力较弱，生成结果就会差很多。下图是我训练一个简单的ResNet后得到的采样结果：<br><img src="/2023/07/07/20230330-diffusion-model/c4.jpg" alt></p>
<p>可以看出，每幅图片都很乱，基本对应不上一个数字。这就是一个较差的训练结果。</p>
<p>如果网络再差一点，可能会生成纯黑或者纯白的图片。这是因为网络的预测结果不准，在反向过程中，图像的均值不断偏移，偏移到远大于1或者远小于-1的值了。</p>
<p>总结一下，在复现DDPM时，最主要是要学习DDPM论文的两个算法，即训练算法和采样算法。两个算法很简单，可以轻松地把它们翻译成代码。而为了成功完成复现，还需要花一点心思在编写U-Net上，尤其是注意处理时间戳的部分。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 深度学习</a>
              <a href="/tags/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" rel="tag"># 扩散模型</a>
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/01/20230622-VQVAE-2/" rel="prev" title="VQVAE PyTorch 实现教程">
      <i class="fa fa-chevron-left"></i> VQVAE PyTorch 实现教程
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/07/20230702-DDIM/" rel="next" title="DDIM 简明讲解与 PyTorch 实现：加速扩散模型采样的通用方法">
      DDIM 简明讲解与 PyTorch 实现：加速扩散模型采样的通用方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90"><span class="nav-number">1.</span> <span class="nav-text">扩散模型与图像生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">扩散模型的具体算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">前向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">反向过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E7%AE%97%E6%B3%95%E4%B8%8E%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">训练算法与采样算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E7%9A%84%E8%A1%A5%E5%85%85-%EF%BC%88%E9%80%89%E8%AF%BB%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">数学推导的补充 （选读）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%99%AA%E5%A3%B0%E9%80%86%E6%93%8D%E4%BD%9C%E5%9D%87%E5%80%BC%E5%92%8C%E6%96%B9%E5%B7%AE%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="nav-number">3.1.</span> <span class="nav-text">加噪声逆操作均值和方差的推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">优化目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%B8%8E%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE"><span class="nav-number">5.</span> <span class="nav-text">参考资料与学习建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">附录：代码复现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="nav-number">6.1.</span> <span class="nav-text">获取数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DDPM-%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">DDPM 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">训练算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%BB%E5%99%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-number">6.4.</span> <span class="nav-text">去噪神经网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%B8%8E%E9%87%87%E6%A0%B7"><span class="nav-number">6.5.</span> <span class="nav-text">实验结果与采样</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhou Yifan</p>
  <div class="site-description" itemprop="description">A foresighted strategist with big-picture thinking. 大局观选手。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
