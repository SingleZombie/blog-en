<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/en/images/logo.svg" color="#222">

<link rel="stylesheet" href="/en/css/main.css">


<link rel="stylesheet" href="/en/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhouyifan.net","root":"/en/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="最近，我需要在Python里使用PatchMatch算法（一种算两张图片逐像素匹配关系的算法）。我去网上搜了一份实现，跑了下测试程序，发现它跑边长300像素的图片都要花三分钟。这个速度实在太慢了。我想起以前瞟到过一篇介绍Python加速的文章，里面提到过Numba这个库。于是，我现学现用，最终成功用Numba让原来要跑180秒的程序在0.6秒左右跑完。可见，Numba学起来是很快的。在这篇文章中，">
<meta property="og:type" content="article">
<meta property="og:title" content="Numba 快速入门示例：让 Python 版 PatchMatch 加速300倍">
<meta property="og:url" content="https://zhouyifan.net/en/2023/05/07/20230506-numba/index.html">
<meta property="og:site_name" content="周弈帆的博客">
<meta property="og:description" content="最近，我需要在Python里使用PatchMatch算法（一种算两张图片逐像素匹配关系的算法）。我去网上搜了一份实现，跑了下测试程序，发现它跑边长300像素的图片都要花三分钟。这个速度实在太慢了。我想起以前瞟到过一篇介绍Python加速的文章，里面提到过Numba这个库。于是，我现学现用，最终成功用Numba让原来要跑180秒的程序在0.6秒左右跑完。可见，Numba学起来是很快的。在这篇文章中，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhouyifan.net/2023/05/07/20230506-numba/1.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/05/07/20230506-numba/2.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/05/07/20230506-numba/3.jpg">
<meta property="og:image" content="https://zhouyifan.net/2023/05/07/20230506-numba/4.jpg">
<meta property="article:published_time" content="2023-05-07T08:01:18.000Z">
<meta property="article:modified_time" content="2023-09-27T16:16:18.344Z">
<meta property="article:author" content="Zhou Yifan">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="计算机科学">
<meta property="article:tag" content="高性能计算">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhouyifan.net/2023/05/07/20230506-numba/1.jpg">

<link rel="canonical" href="https://zhouyifan.net/en/2023/05/07/20230506-numba/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Numba 快速入门示例：让 Python 版 PatchMatch 加速300倍 | 周弈帆的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/en/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">周弈帆的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/en/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/en/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-switch_lang">

    <a href="https://zhouyifan.net" rel="section"><i class="fa fa-language fa-fw"></i>简体中文</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/en/2023/05/07/20230506-numba/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/en/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="Designer, artist, philosopher, researcher.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Numba 快速入门示例：让 Python 版 PatchMatch 加速300倍
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-05-07 16:01:18" itemprop="dateCreated datePublished" datetime="2023-05-07T16:01:18+08:00">2023-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/en/categories/%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">记录</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/en/categories/%E8%AE%B0%E5%BD%95/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>最近，我需要在Python里使用PatchMatch算法（一种算两张图片逐像素匹配关系的算法）。我去网上搜了一份实现，跑了下测试程序，发现它跑边长300像素的图片都要花三分钟。这个速度实在太慢了。我想起以前瞟到过一篇介绍Python加速的文章，里面提到过Numba这个库。于是，我现学现用，最终成功用Numba让原来要跑180秒的程序在0.6秒左右跑完。可见，Numba学起来是很快的。在这篇文章中，我将以这个Python版PatchMatch项目为例，介绍如何快速从零上手Numba，以大幅加速Python科学计算程序。这篇文章不会涉及PatchMatch算法的原理，只要你写过Python，就能读懂本文。</p>
<h2 id="缘起：一份缓慢的-PatchMatch-实现"><a href="#缘起：一份缓慢的-PatchMatch-实现" class="headerlink" title="缘起：一份缓慢的 PatchMatch 实现"></a>缘起：一份缓慢的 PatchMatch 实现</h2><p>PatchMatch是Adobe提出的一种快速计算两张图片逐像素匹配关系的算法。也就是说，输入两张类似的图片A和B（比如视频里的连续两帧），算法能输出图片A中的每个像素对应B中的哪个像素（可能会出现多对一的情况）。为了快速验证算法的效果，我们可以输入图片A和B，用算法获取A到B的匹配关系，再根据匹配关系从B中取像素重建A。如果重建出来的图片和原来的图片A看上去差不多，那算法的效果就很不错。下图是一份PatchMatch测试程序的输出。</p>
<p><img src="/2023/05/07/20230506-numba/1.jpg" alt></p>
<p>我在GitHub上找到了一份简明实用的<a target="_blank" rel="noopener" href="https://github.com/MingtaoGuo/PatchMatch">Python版PatchMatch实现</a>，得到了上面的输出结果。结果是挺不错，但哪怕是跑<code>326x244</code>这么小的图片，都要花约180秒才能跑完。</p>
<p>我懒得从头学一遍PatchMatch，决定直接上手优化代码。代码不长，其函数调用关系能很快理清。</p>
<p>代码入口函数是<code>NNS()</code>。它先是调用了<code>initialization()</code>，再循环<code>itr</code>次，每次遍历所有像素，对每个像素调用<code>propagation()</code>和<code>random_search()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NNS</span>(<span class="params">img, ref, p_size, itr</span>):</span></span><br><span class="line">    A_h = np.size(img, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(img, <span class="number">1</span>)</span><br><span class="line">    f, dist, img_padding = initialization(img, ref, p_size)</span><br><span class="line">    <span class="keyword">for</span> itr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, itr + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> itr % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    a = np.array([i, j])</span><br><span class="line">                    propagation(f, a, dist, img_padding, ref, p_size, <span class="literal">False</span>)</span><br><span class="line">                    random_search(f, a, dist, img_padding, ref, p_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w):</span><br><span class="line">                    a = np.array([i, j])</span><br><span class="line">                    propagation(f, a, dist, img_padding, ref, p_size, <span class="literal">True</span>)</span><br><span class="line">                    random_search(f, a, dist, img_padding, ref, p_size)</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<p><code>initialization()</code>先是定义了一些变量，之后对所有像素调用<code>cal_distance()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization</span>(<span class="params">A, B, p_size</span>):</span></span><br><span class="line">    A_h = np.size(A, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(A, <span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w):</span><br><span class="line">            ...</span><br><span class="line">            dist[i, j] = cal_distance(a, b, A_padding, B, p_size)</span><br><span class="line">    <span class="keyword">return</span> f, dist, A_padding</span><br></pre></td></tr></table></figure>
<p><code>propagation()</code>主要调用了一次<code>cal_distance()</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagation</span>(<span class="params">f, a, dist, A_padding, B, p_size, is_odd</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> is_odd:</span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">1</span>:</span><br><span class="line">            ...</span><br><span class="line">            dist[x, y] = cal_distance(a, f[x, y], A_padding, B, p_size)</span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">            ...</span><br><span class="line">            dist[x, y] = cal_distance(a, f[x, y], A_padding, B, p_size)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 和 is_odd 时类似</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p><code>random_search()</code>则主要是在一个while循环里反复调用<code>cal_distance()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_search</span>(<span class="params">f, a, dist, A_padding, B, p_size, alpha=<span class="number">0.5</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> search_h &gt; <span class="number">1</span> <span class="keyword">and</span> search_w &gt; <span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        d = cal_distance(a, b, A_padding, B, p_size)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>最后来看被调用最多的<code>cal_distance()</code>。这个函数用于计算图片<code>A</code>,<code>B</code>之间的某个距离。也别管这个距离是什么意思，总之是这一个有点耗时的计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">a, b, A_padding, B, p_size</span>):</span></span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    patch_a = A_padding[a[<span class="number">0</span>]:a[<span class="number">0</span>] + p_size, a[<span class="number">1</span>]:a[<span class="number">1</span>] + p_size, :]</span><br><span class="line">    patch_b = B[b[<span class="number">0</span>] - p:b[<span class="number">0</span>] + p + <span class="number">1</span>, b[<span class="number">1</span>] - p:b[<span class="number">1</span>] + p + <span class="number">1</span>, :]</span><br><span class="line">    temp = patch_b - patch_a</span><br><span class="line">    num = np.<span class="built_in">sum</span>(<span class="number">1</span> - np.int32(np.isnan(temp)))</span><br><span class="line">    dist = np.<span class="built_in">sum</span>(np.square(np.nan_to_num(temp))) / num</span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，这份程序就差不多看完了。可以发现，代码大部分时候都在遍历像素，且遍历每个像素时多次调用<code>cal_distance()</code>函数。而我们知道，拿Python本身做计算是很慢的，尤其是在一个很长的循环里反复计算。这份代码性能较低，正是因为代码在遍历每个像素时做了大量计算。</p>
<p>我以前看过一篇文章，说Numba库能够加速Python科学计算程序，尤其是加速带有大量循环的程序。于是，我去学习了一下Numba的基础用法。</p>
<h2 id="Numba-基础"><a href="#Numba-基础" class="headerlink" title="Numba 基础"></a>Numba 基础</h2><p>Numba的官方文档提供了非常友好的<a target="_blank" rel="noopener" href="https://numba.readthedocs.io/en/stable/user/5minguide.html">入门教程</a>。我们来大致把教程过一下。</p>
<p>Numba可以用pip一键安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numba</span><br></pre></td></tr></table></figure>
<p>Numba尤其擅长加速循环以及和NumPy相关的计算。使用<code>@jit(nopython=True)</code>（或<code>@njit</code>）装饰一个函数后，我们可以在这个函数里随便写循环，随便用NumPy计算，就像在用C语言一样。经Numba优化后，这个函数会跑得飞快。以下是官方给出的入门示例程序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit, njit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>)  </span><span class="comment"># 设置 &quot;nopython&quot; 模式以获取最优性能，等价于 @njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_fast</span>(<span class="params">a</span>):</span>  <span class="comment"># 初次调用时函数将被编译成机器码</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">0</span>]):  <span class="comment"># Numba 喜欢循环</span></span><br><span class="line">        trace += np.tanh(a[i, i])  <span class="comment"># Numba 喜欢 NumPy 函数</span></span><br><span class="line">    <span class="keyword">return</span> a + trace  <span class="comment"># Numba 喜欢 NumPy 广播</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(go_fast(x))</span><br></pre></td></tr></table></figure>
<p>Numba是怎么完成加速的呢？从装饰器名<code>jit</code>（JIT，Just-In-Time Compiler的简称）中，我们能猜出，Numba使用了即时编译技术，把函数直接翻译成了机器码，而没有像普通Python程序一样解释执行。Numba有两种编译模式，最常见的模式是令参数<code>nopython=True</code>，在编译中完全不用Python解释器。这种模式下，函数能以最优性能翻译成机器码。</p>
<p>修改上面的代码，我们可以测试该函数的速度。注意，由于采用了即时编译，函数在初次调用时会被编译。如果只要计算函数在编译后的运行时间，应该从第二次调用后开始计时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_fast</span>(<span class="params">a</span>):</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">0</span>]):</span><br><span class="line">        trace += np.tanh(a[i, i])</span><br><span class="line">    <span class="keyword">return</span> a + trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要汇报这个速度，因为编译时间也被算进去了</span></span><br><span class="line">start = time.perf_counter()</span><br><span class="line">go_fast(x)</span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Elapsed (with compilation) = &#123;&#125;s&quot;</span>.<span class="built_in">format</span>((end - start)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在函数已经被编译了，用缓存好的函数重新计时</span></span><br><span class="line">start = time.perf_counter()</span><br><span class="line">go_fast(x)</span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Elapsed (after compilation) = &#123;&#125;s&quot;</span>.<span class="built_in">format</span>((end - start)))</span><br></pre></td></tr></table></figure>
<p>我们可以得到类似于下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Elapsed (with compilation) = 1.0579542s</span><br><span class="line">Elapsed (after compilation) = 1.7699999999898353e-05s</span><br></pre></td></tr></table></figure>
<p>我们可以尝试一下不用Numba，直接用Python循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_slowly</span>(<span class="params">a</span>):</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">0</span>]):</span><br><span class="line">        trace += np.tanh(a[i, i])</span><br><span class="line">    <span class="keyword">return</span> a + trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.perf_counter()</span><br><span class="line">go_slowly(x)</span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Elapsed (without Numba) = &#123;&#125;s&quot;</span>.<span class="built_in">format</span>((end - start)))</span><br></pre></td></tr></table></figure>
<p>这个速度（<code>4e-4</code>）比用Numba慢了一个数量级。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elapsed (without Numba) = 0.00046979999999985367s</span><br></pre></td></tr></table></figure><br>也就是说，我们只要在普通的Python计算函数上加一个<code>@jit(nopython=True)</code>（或<code>@njit</code>），其他什么都不用做，就可以加速代码了。让我们来用它改进一下之前的PatchMatch程序。</p>
<h2 id="用Numba计时编译加速PatchMatch"><a href="#用Numba计时编译加速PatchMatch" class="headerlink" title="用Numba计时编译加速PatchMatch"></a>用Numba计时编译加速PatchMatch</h2><p>让我们开始做PatchMatch的性能调优。首先，根据性能优化的一般做法，我们要得知每一行函数调用的运行时间，找到性能瓶颈，从瓶颈处开始优化。我们可以用<code>line_profiler</code>来分析每一行代码的运行时间。用pip即可安装这个库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install line_profiler</span><br></pre></td></tr></table></figure>
<p>把主函数修改一下，在调用算法入口函数时拿<code>LineProfiler</code>封装一下，再用<code>lp.add_function</code>添加想监控的函数，即可开始性能分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    img = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;./cup_a.jpg&quot;</span>))</span><br><span class="line">    ref = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;./cup_b.jpg&quot;</span>))</span><br><span class="line">    p_size = <span class="number">3</span></span><br><span class="line">    itr = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># start = time.time()</span></span><br><span class="line">    <span class="comment"># f = NNS(img, ref, p_size, itr)</span></span><br><span class="line">    <span class="comment"># end = time.time()</span></span><br><span class="line">    <span class="comment"># print(end - start)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># reconstruction(f, img, ref)</span></span><br><span class="line"></span><br><span class="line">    lp = LineProfiler()</span><br><span class="line">    lp_wrapper = lp(NNS)</span><br><span class="line">    lp.add_function(propagation)</span><br><span class="line">    lp.add_function(random_search)</span><br><span class="line">    f = lp_wrapper(img, ref, p_size, itr)</span><br><span class="line">    lp.print_stats()</span><br></pre></td></tr></table></figure>
<p>性能分析结果会显示每一行代码的运行时间及占用时间百分比。从结果中可以看出，在入口函数<code>NNS()</code>中，<code>random_search()</code>最为耗时。这是符合预期的，因为<code>random_search()</code>里还有一层while循环。</p>
<p><img src="/2023/05/07/20230506-numba/2.jpg" alt></p>
<p>现在，我们应该着重优化<code>random_search()</code>的性能。我们继续查看一下<code>random_search()</code>的性能分析结果。</p>
<p><img src="/2023/05/07/20230506-numba/3.jpg" alt></p>
<p>结果显示，绝大多数时间都消耗在了while循环里。也和我们之前分析得一样，<code>cal_distance()</code>是耗时最多的一行。除了<code>random_search()</code>外，其他几个函数也多次调用了<code>cal_distance()</code>。因此，我们目前代码优化的目标就定格在了<code>cal_distance()</code>身上。</p>
<p>刚刚学完了Numba，这不正好可以用上了吗？我们可以尝试直接给<code>cal_distance()</code>加一个<code>@njit</code>装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">a, b, A_padding, B, p_size</span>):</span></span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    patch_a = A_padding[a[<span class="number">0</span>]:a[<span class="number">0</span>] + p_size, a[<span class="number">1</span>]:a[<span class="number">1</span>] + p_size, :]</span><br><span class="line">    patch_b = B[b[<span class="number">0</span>] - p:b[<span class="number">0</span>] + p + <span class="number">1</span>, b[<span class="number">1</span>] - p:b[<span class="number">1</span>] + p + <span class="number">1</span>, :]</span><br><span class="line">    temp = patch_b - patch_a</span><br><span class="line">    num = np.<span class="built_in">sum</span>(<span class="number">1</span> - np.int32(np.isnan(temp)))</span><br><span class="line">    dist = np.<span class="built_in">sum</span>(np.square(np.nan_to_num(temp))) / num</span><br><span class="line">    <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure>
<p>修改完代码后，再次运行程序。这次，程序报了一大堆错误。大致是说，在某一行碰到了Numba识别不了的函数。应该把<code>np.int32()</code>的强制类型转换改成<code>.astype(np.int32)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = np.sum(1 - np.int32(np.isnan(temp)))</span><br><span class="line">^</span><br></pre></td></tr></table></figure>
<p>改完之后，如果Numba版本较老，还会碰到新的报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use of unsupported NumPy function &#x27;numpy.nan_to_num&#x27; or unsupported use of the function.</span><br></pre></td></tr></table></figure>
<p>报错显示，<code>numpy.nan_to_num</code>函数没有得到支持。再次翻阅Numba文档，可以发现，<strong>Numba并不支持所有NumPy函数</strong>。Numba对NumPy的支持情况可以在<a target="_blank" rel="noopener" href="https://numba.readthedocs.io/en/stable/reference/numpysupported.html">文档</a>里查询（需要把文档切换到你当前Numba的版本）。</p>
<p>总之，<code>cal_distance()</code>这个函数不改不行了。得认真阅读一下这个函数的原理。原来，<code>cal_distance(a, b, A_padding, B, p_size)</code>函数是算图像<code>A_padding</code>和图像<code>B</code>中某一个像素块的均方误差的平均值，其中，像素块的边长为<code>p_size</code>，像素块在<code>A_padding</code>的坐标由<code>a</code>表示，在<code>B</code>中的坐标由<code>b</code>表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">a, b, A_padding, B, p_size</span>):</span></span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 根据坐标a和边长p从A_padding里取像素块</span></span><br><span class="line">    patch_a = A_padding[a[<span class="number">0</span>]:a[<span class="number">0</span>] + p_size, a[<span class="number">1</span>]:a[<span class="number">1</span>] + p_size, :]</span><br><span class="line">    <span class="comment"># 根据坐标b和边长p从A_padding里取像素块</span></span><br><span class="line">    patch_b = B[b[<span class="number">0</span>] - p:b[<span class="number">0</span>] + p + <span class="number">1</span>, b[<span class="number">1</span>] - p:b[<span class="number">1</span>] + p + <span class="number">1</span>, :]</span><br><span class="line">    <span class="comment"># 求差</span></span><br><span class="line">    temp = patch_b - patch_a</span><br><span class="line">    <span class="comment"># 根据非nan像素数量算有效像素数量</span></span><br><span class="line">    num = np.<span class="built_in">sum</span>(<span class="number">1</span> - np.isnan(temp).astype(np.int32))</span><br><span class="line">    <span class="comment"># 排除nan，求差的平方和，再除以有效像素数量</span></span><br><span class="line">    dist = np.<span class="built_in">sum</span>(np.square(np.nan_to_num(temp))) / num</span><br><span class="line">    <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure>
<p>代码里还有一些奇怪的有关nan的运算：如果像素块里某处有nan，就说明此处像素无效，不应该参与均方误差的运算。为什么图像里会有nan呢？我们得阅读代码的其他部分。</p>
<p>nan是在初始化函数<code>initialization()</code>里加入的。<code>A_padding</code>原来是图像<code>A</code>在周围填了一圈nan的结果。我们大致能猜测出作者填充nan的原因：从<code>A</code>中取像素块时，若像素块在边缘，则有一些像素就不应该被计算了。拿条件语句判断这些无效像素比较麻烦，作者选择干脆在图像<code>A</code>周围填一圈nan，保证每次取像素块时不用判断无效像素。等算误差的时候再判断根据nan排除无效像素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization</span>(<span class="params">A, B, p_size</span>):</span></span><br><span class="line">    A_h = np.size(A, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(A, <span class="number">1</span>)</span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    A_padding = np.ones([A_h + p * <span class="number">2</span>, A_w + p * <span class="number">2</span>, <span class="number">3</span>]) * np.nan</span><br><span class="line">    A_padding[p:A_h + p, p:A_w + p, :] = A</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/07/20230506-numba/4.jpg" alt></p>
<p>使用nan填充，既耗时，兼容性又不好。为了尽可能加速<code>cal_distance()</code>，我把填充改成了<code>edge</code>填充，即让填充值等于边界值，并取消了无效像素的判断。也就是说，若像素块取到了图像外的像素，则认为这个像素和边界处的像素一样。这个假设是很合理的，这种修改几乎不会损耗算法的效果。</p>
<p>除此之外，为了进一步减少<code>cal_distance()</code>中的计算，我把要用到的变量都提前在外面算好再传进来。由于现在不需要考虑无效像素的数量，可以直接对误差求和，不用再算平均值，少做一次除法。还有，现在用<code>@njit</code>装饰了函数，可以放心大胆地在循环里做计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization</span>(<span class="params">A, B, p_size</span>):</span></span><br><span class="line">    A_h = np.size(A, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(A, <span class="number">1</span>)</span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    A_padding = np.pad(A, ((p, p), (p, p), (<span class="number">0</span>, <span class="number">0</span>)), mode=<span class="string">&#x27;edge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Numba 循环写法</span></span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">x, y, x2, y2, A_padding, B, p</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(p + p + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(p + p + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                a = <span class="built_in">float</span>(A_padding[x + i, y + j, k])</span><br><span class="line">                bb = B[x2 - p + i, y2 - p + j, k]</span><br><span class="line">                <span class="built_in">sum</span> += (a - bb)**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>
<p>当然，用NumPy实现<code>cal_distance</code>也是可以的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy 等价写法，加上@njit更快</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">x, y, x2, y2, A_padding, B, p</span>):</span></span><br><span class="line">    patch_a = A_padding[x:x + p, y:y + p, :].astype(np.float32)</span><br><span class="line">    patch_b = B[x2 - p:x2 + p + <span class="number">1</span>, y2 - p:y2 + p + <span class="number">1</span>, :]</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">sum</span>((patch_a - patch_b)**<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>经测试，把nan的判断全部去掉后，使用NumPy版的<code>cal_distance()</code>，程序的运行时间降到了60秒。给NumPy版的<code>cal_distance()</code>加上<code>@njit</code>，运行时间进一步降低到了33秒。而如果使用带<code>@njit</code>装饰的循环写法，则运行时间也差不多是33秒，甚至还略快一些。这些测试结果印证了Numba的特性：</p>
<ol>
<li>Numba可以加速和NumPy张量相关的计算 </li>
<li>在Numba中使用循环不会降低运行速度</li>
</ol>
<p>成功用<code>@njit</code>优化完了代码中最深层的<code>cal_distance()</code>，我们会想，是不是所有函数都可以用同样方法加速？我们可以来做个实验，给最外层的入口函数<code>NNS()</code>加上<code>@njit</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NNS</span>(<span class="params">img, ref, p_size, itr</span>):</span></span><br><span class="line">    A_h = np.size(img, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(img, <span class="number">1</span>)</span><br><span class="line">    f, dist, img_padding = initialization(img, ref, p_size)</span><br><span class="line">    <span class="keyword">for</span> itr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, itr + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> itr % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    a = np.array([i, j])</span><br><span class="line">                    propagation(f, a, dist, img_padding, ref, p_size, <span class="literal">False</span>)</span><br><span class="line">                    random_search(f, a, dist, img_padding, ref, p_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w):</span><br><span class="line">                    a = np.array([i, j])</span><br><span class="line">                    propagation(f, a, dist, img_padding, ref, p_size, <span class="literal">True</span>)</span><br><span class="line">                    random_search(f, a, dist, img_padding, ref, p_size)</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<p>运行程序，会得到类似于下面的报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Untyped global name &#x27;initialization&#x27;: Cannot determine Numba type of &lt;class &#x27;function&#x27;&gt;</span><br></pre></td></tr></table></figure><br>把报错放网上一搜，原来，<strong>加<code>@njit</code>的自定义函数只能调用加<code>@njit</code>的自定义函数</strong>。也就是说，在上面这份代码里，我们虽然用<code>@njit</code>装饰了<code>NNS()</code>，但我们自己定义的<code>initialization()</code>, <code>propagation()</code>,<code>random_search()</code>全部都没有用<code>@njit</code>装饰，因此<code>NNS()</code>的编译会出错。看来，我们得自底向上一步一步加上<code>@njit</code>了。</p>
<p>先来尝试修改一下<code>initialization()</code>。很可惜，直接加上<code>@njit</code>会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization</span>(<span class="params">A, B, p_size</span>):</span></span><br><span class="line">    A_h = np.size(A, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(A, <span class="number">1</span>)</span><br><span class="line">    B_h = np.size(B, <span class="number">0</span>)</span><br><span class="line">    B_w = np.size(B, <span class="number">1</span>)</span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    random_B_r = np.random.randint(p, B_h - p, [A_h, A_w])</span><br><span class="line">    random_B_c = np.random.randint(p, B_w - p, [A_h, A_w])</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#报错</span></span><br><span class="line"><span class="comment"># Use of unsupported NumPy function &#x27;numpy.size&#x27; or unsupported use of the function.</span></span><br></pre></td></tr></table></figure>
<p>报错是说有不支持的NumPy函数<code>numpy.size</code>。实际上，不仅是<code>numpy.size</code>，Numba也不支持有三个参数的<code>np.random.randint</code>。为了解决此问题，和刚刚对<code>numpy.nan_to_num</code>的处理一样，最好是能用其他等价写法来代替不支持的函数。如果不行的话，则应该把不支持的运算和支持的运算分离开，只加速支持的那一部分。对于<code>initialization()</code>，我采用了第二种解决方法，把函数中耗时的循环拆开来单独用<code>@njit</code>装饰，其余有不支持的NumPy函数的部分就不用Numba优化了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization_loop</span>(<span class="params">A_padding, B, f, dist, A_h, A_w, random_B_r,</span></span></span><br><span class="line"><span class="params"><span class="function">                        random_B_c, p</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w):</span><br><span class="line">            x, y = random_B_r[i, j], random_B_c[i, j]</span><br><span class="line">            f[i, j, <span class="number">0</span>] = x</span><br><span class="line">            f[i, j, <span class="number">1</span>] = y</span><br><span class="line">            dist[i, j] = cal_distance(i, j, x, y, A_padding, B, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization</span>(<span class="params">A, B, A_h, A_w, B_h, B_w, p_size</span>):</span></span><br><span class="line">    p = p_size // <span class="number">2</span></span><br><span class="line">    random_B_r = np.random.randint(p, B_h - p, [A_h, A_w])</span><br><span class="line">    random_B_c = np.random.randint(p, B_w - p, [A_h, A_w])</span><br><span class="line">    A_padding = np.pad(A, ((p, p), (p, p), (<span class="number">0</span>, <span class="number">0</span>)), mode=<span class="string">&#x27;edge&#x27;</span>)</span><br><span class="line">    f = np.zeros([A_h, A_w, <span class="number">2</span>], dtype=np.int32)</span><br><span class="line">    dist = np.zeros([A_h, A_w])</span><br><span class="line">    initialization_loop(A_padding, B, f, dist, A_h, A_w, random_B_r,</span><br><span class="line">                        random_B_c, p)</span><br><span class="line">    <span class="keyword">return</span> f, dist, A_padding</span><br></pre></td></tr></table></figure>
<p>另外的两个函数<code>propagation()</code>和<code>random_search()</code>只会碰到取形状函数<code>numpy.size</code>的问题。这个问题很好解决，只要把<code>numpy.size</code>挪到函数调用外即可。</p>
<p>给<code>initialization_loop()</code>、<code>propagation()</code>、<code>random_search()</code>都加上<code>@njit</code>后，程序的运行时间从33秒猛地降到了3秒左右。可以说，只用加<code>@njit</code>的方法的话，程序已经没有优化空间了。</p>
<h2 id="用Numba提前编译加速PatchMatch"><a href="#用Numba提前编译加速PatchMatch" class="headerlink" title="用Numba提前编译加速PatchMatch"></a>用Numba提前编译加速PatchMatch</h2><p>又看了看PatchMatch的源码，我发现，PatchMatch算法会先为每个像素随机生成一个匹配关系。然后，算法会迭代更新匹配关系。迭代得越久，匹配关系越准。而我之后要用PatchMatch处理一段视频，算所有帧对第1帧的匹配关系。那么，对于视频这种连续的图像序列，我能不能让第3帧初始化匹配关系时复用第2帧的匹配结果，第4帧复用第3帧的匹配关系，以此类推，以减少迭代次数呢？</p>
<p>说干就干。我准备先测试一下减少迭代次数后代码运行时间能缩短多少。迭代次数<code>itr</code>是在main函数里指定的，作者默认的数值是5。我把它改成1测试了一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    img = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;./cup_a.jpg&quot;</span>))</span><br><span class="line">    ref = np.array(Image.<span class="built_in">open</span>(<span class="string">&quot;./cup_b.jpg&quot;</span>))</span><br><span class="line">    p = <span class="number">3</span></span><br><span class="line">    itr = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    f = NNS(img, ref, p, itr)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end - start)</span><br><span class="line">    reconstruction(f, img, ref)</span><br></pre></td></tr></table></figure>
<p>结果，原来要花3秒的程序还是要花接近3秒，时间缩短得非常不明显。这不应该啊，理论上程序的运行时间应该大致和<code>itr</code>成正比啊。</p>
<p>测试了半天，我突然想起Numba文档里讲过，<code>@njit</code>是即时编译，函数的编译会在初次调用函数时完成。我每次运行程序时，大部分时间都花在了编译上，因此整个程序的运行时间几乎不由迭代次数决定。</p>
<p>我之后要反复运行PatchMatch程序，而不是通过运行一次程序来处理大批数据。即时编译的代价我是接受不了的。于是，我去文档里找到了Numba提前编译（AOT，ahead of time）的使用方法。</p>
<p>Numba AOT可以把Python函数编译进一个模块文件中。想在其他地方调用被编译的函数时，只需要<code>import 模块名</code>即可 。</p>
<p>官方给出的Numba AOT示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numba.pycc <span class="keyword">import</span> CC</span><br><span class="line"></span><br><span class="line">cc = CC(<span class="string">&#x27;my_module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@cc.export(<span class="params"><span class="string">&#x27;multf&#x27;</span>, <span class="string">&#x27;f8(f8, f8)&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@cc.export(<span class="params"><span class="string">&#x27;multi&#x27;</span>, <span class="string">&#x27;i4(i4, i4)&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mult</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="meta">@cc.export(<span class="params"><span class="string">&#x27;square&#x27;</span>, <span class="string">&#x27;f8(f8)&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cc.<span class="built_in">compile</span>()</span><br></pre></td></tr></table></figure>
<p>首先，程序要用一个模块名实例化一个<code>CC</code>。该模块名是未来我们<code>import</code>时用到的名称。之后，对于想编译的函数，我们要用<code>@cc.export</code>装饰它。<code>@cc.export</code>的第一个参数是调用时的函数名（原来的函数名会被舍弃），第二个参数用于指定函数返回值和参数的类型。做完所有这些准备后，使用<code>cc.compile()</code>即可完成编译。</p>
<p>运行该程序，会得到一个模块文件。根据平台的不同，该模块文件名可能是<code>my_module.so</code>、<code>my_module.pyd</code>或<code>my_module.cpython-34m.so</code>。不管文件名是什么，只要是在同一个文件夹下，我们就可以用下面的Python命令调用这个模块文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> my_module</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_module.multi(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_module.square(<span class="number">1.414</span>)</span><br><span class="line"><span class="number">1.9993959999999997</span></span><br></pre></td></tr></table></figure>
<p>用Numba做即时编译时，函数的返回值类型和参数类型可填可不填。而Numba提前编译中，必须要填入函数的返回值类型和参数类型。这让编写Numba提前编译的工作量大了不少，已经不像是在写Python，而是在写C了。</p>
<p>还有一点值得注意。和使用即时编译时一样，自定义的函数在调用其他自定义函数时，必须要加上<code>@njit</code>。所以，会出现一个函数即有<code>@njit</code>，又有<code>@cc.export</code>的情况。</p>
<p>学习使用Numba提前编译时，最主要是要学习Numba是怎么用字符串代表参数类型的。比如，<code>i4</code>是32位整型，<code>u1</code>是8位无符号整型，<code>u1[:, :, :]</code>是三维8位无符号整型，<code>void</code>是无返回值。这些表示可以在官方文档里找到。</p>
<p>以我写的Numba AOT PatchMatch的编译代码为例，我们可以看一看参数类型和返回值类型是怎么描述的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> njit</span><br><span class="line"><span class="keyword">from</span> numba.pycc <span class="keyword">import</span> CC</span><br><span class="line"></span><br><span class="line">cc = CC(<span class="string">&#x27;patch_match_module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="meta">@cc.export(<span class="params"><span class="string">&#x27;cal_distance&#x27;</span>, <span class="string">&#x27;f4(i4, i4, i4, i4, u1[:, :, :], u1[:, :, :], i4)&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">x, y, x2, y2, A_padding, B, p</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="meta">@cc.export(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="string">&#x27;initialization_loop&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="string">&#x27;void(u1[:, :, :], u1[:, :, :], i4[:, :, :], f4[:, :], i4, i4, i4[:, :], i4[:, :], i4)&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialization_loop</span>(<span class="params">A_padding, B, f, dist, A_h, A_w, random_B_r,</span></span></span><br><span class="line"><span class="params"><span class="function">                        random_B_c, p</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="meta">@cc.export(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="string">&#x27;propagation&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="string">&#x27;void(i4[:, :, :], i4, i4, i4, i4, f4[:, :], u1[:, :, :], u1[:, :, :], i4, b1)&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagation</span>(<span class="params">f, x, y, A_h, A_w, dist, A_padding, B, p_size, is_odd</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@njit</span></span><br><span class="line"><span class="meta">@cc.export(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="string">&#x27;random_search&#x27;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="string">&#x27;void(i4[:, :, :], i4, i4, i4, i4, f4[:, :], u1[:, :, :], u1[:, :, :], i4, f4)&#x27;</span></span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_search</span>(<span class="params">f, x, y, B_h, B_w, dist, A_padding, B, p_size, alpha=<span class="number">0.5</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cc.<span class="built_in">compile</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行该程序后，在我的电脑上得到了名为<code>patch_match_module.cp37-win_amd64.pyd</code>的模块文件。可以在其他代码里通过<code>import patch_match_module</code>调用编译好的函数了，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> patch_match_module</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NNS</span>(<span class="params">img, ref, p_size, itr</span>):</span></span><br><span class="line">    A_h = np.size(img, <span class="number">0</span>)</span><br><span class="line">    A_w = np.size(img, <span class="number">1</span>)</span><br><span class="line">    B_h = np.size(ref, <span class="number">0</span>)</span><br><span class="line">    B_w = np.size(ref, <span class="number">1</span>)</span><br><span class="line">    f, dist, img_padding = initialization(img, ref, A_h, A_w, B_h, B_w, p_size)</span><br><span class="line">    <span class="keyword">for</span> itr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, itr + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> itr % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    patch_match_module.propagation(f, i, j, A_h, A_w, dist,</span><br><span class="line">                                                   img_padding, ref, p_size,</span><br><span class="line">                                                   <span class="literal">False</span>)</span><br><span class="line">                    patch_match_module.random_search(f, i, j, B_h, B_w, dist,</span><br><span class="line">                                                     img_padding, ref, p_size,</span><br><span class="line">                                                     <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A_h):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(A_w):</span><br><span class="line">                    patch_match_module.propagation(f, i, j, A_h, A_w, dist,</span><br><span class="line">                                                   img_padding, ref, p_size,</span><br><span class="line">                                                   <span class="literal">True</span>)</span><br><span class="line">                    patch_match_module.random_search(f, i, j, B_h, B_w, dist,</span><br><span class="line">                                                     img_padding, ref, p_size,</span><br><span class="line">                                                     <span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
<p>加上最后这步提前编译后，PatchMatch的运行时间从3秒降低到了0.6秒多。程序从最开始的180秒降到了0.6秒，几乎快了300倍。而且，如果是处理视频，还可以通过复用前一帧信息来减少迭代次数，进一步缩短每一帧的平均处理时间。能加速这么多，并不是我太强，而是Python实在太慢了。纯Python就不应该用来写科学计算程序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读这篇文章，相信大家能根据我这次Python PatchMatch性能优化经历，在不阅读Numba文档的前提下自然而然地学会Numba的用法。我把文章中提到的和Numba性能优化有关的知识点按使用顺序总结一下。</p>
<ol>
<li>在面向应用的程序中，不要用Python写科学计算程序。哪怕要写，也要尽可能避免在循环中使用大量计算，而是去调用各个库的向量化计算。</li>
<li>直接在想优化的函数前加<code>@njit</code>装饰。在待优化函数里使用循环、NumPy函数都是很欢迎的。</li>
<li>如果碰到了Numba不支持的函数，可以通过两种方式解决：1）用等价的Numba支持的函数代替；2）把不支持和支持的部分分离，只加速支持的部分。</li>
<li>一个带<code>@njit</code>函数在调用另一个自定义的函数时，那个函数也得加上<code>@njit</code>。因此，应该自底向上地实现Numba即时编译函数。</li>
<li>如果你接受不了计时编译的编译时间，可以使用提前编译技术。使用提前编译时，主要的工作是给参数和返回值标上正确的类型。</li>
</ol>
<p>Numba确实很容易上手，只要会加<code>@njit</code>，剩下碰到了什么问题去搜索一下就行。Numba的<a target="_blank" rel="noopener" href="https://numba.pydata.org/numba-doc/dev/user/index.html">官方文档</a>很详细，想深入学习的话直接看文档就行了。</p>
<p>本项目的代码仓库为：<a target="_blank" rel="noopener" href="https://github.com/SingleZombie/Fast-Python-PatchMatch">https://github.com/SingleZombie/Fast-Python-PatchMatch</a> 。在原作者仓库的基础上，我添加了<code>PatchMatch_numba_jit.py</code>、<code>PatchMatch_numba_compile.py</code>、<code>PatchMatch_numba_aot.py</code>这三个文件。它们分别表示即时编译运行程序、提前编译编译程序、提前编译运行程序。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/en/tags/Python/" rel="tag"># Python</a>
              <a href="/en/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" rel="tag"># 计算机科学</a>
              <a href="/en/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/" rel="tag"># 高性能计算</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/en/2023/04/05/20230209-toefl-experience/" rel="prev" title="37天考5次托福 ~ 噩梦般的体验">
      <i class="fa fa-chevron-left"></i> 37天考5次托福 ~ 噩梦般的体验
    </a></div>
      <div class="post-nav-item">
    <a href="/en/2023/05/27/20230522-pixelcnn/" rel="next" title="冷门的自回归生成模型 ~ 详解 PixelCNN 大家族">
      冷门的自回归生成模型 ~ 详解 PixelCNN 大家族 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%98%E8%B5%B7%EF%BC%9A%E4%B8%80%E4%BB%BD%E7%BC%93%E6%85%A2%E7%9A%84-PatchMatch-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">缘起：一份缓慢的 PatchMatch 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Numba-%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Numba 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8Numba%E8%AE%A1%E6%97%B6%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9FPatchMatch"><span class="nav-number">3.</span> <span class="nav-text">用Numba计时编译加速PatchMatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8Numba%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9FPatchMatch"><span class="nav-number">4.</span> <span class="nav-text">用Numba提前编译加速PatchMatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhou Yifan</p>
  <div class="site-description" itemprop="description">Designer, artist, philosopher, researcher.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/en/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/en/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/en/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/en/lib/anime.min.js"></script>
  <script src="/en/lib/velocity/velocity.min.js"></script>
  <script src="/en/lib/velocity/velocity.ui.min.js"></script>

<script src="/en/js/utils.js"></script>

<script src="/en/js/motion.js"></script>


<script src="/en/js/schemes/muse.js"></script>


<script src="/en/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
