<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/en/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/en/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/en/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/en/images/logo.svg" color="#222">

<link rel="stylesheet" href="/en/css/main.css">


<link rel="stylesheet" href="/en/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhouyifan.net","root":"/en/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="近期，最受开源社区欢迎的文生图模型 Stable Diffusion 的最新版本 Stable Diffusion 3 开放了源码和模型参数。开发者宣称，Stable Diffusion 3 使用了全新的模型结构和文本编码方法，能够生成更符合文本描述且高质量的图片。得知 Stable Diffusion 3 开源后，社区用户们纷纷上手测试，在网上分享了许多测试结果。而在本文中，我将面向之前已经熟悉">
<meta property="og:type" content="article">
<meta property="og:title" content="Stable Diffusion 3 论文及源码概览">
<meta property="og:url" content="https://zhouyifan.net/en/2024/07/14/20240703-SD3/index.html">
<meta property="og:site_name" content="周弈帆的博客">
<meta property="og:description" content="近期，最受开源社区欢迎的文生图模型 Stable Diffusion 的最新版本 Stable Diffusion 3 开放了源码和模型参数。开发者宣称，Stable Diffusion 3 使用了全新的模型结构和文本编码方法，能够生成更符合文本描述且高质量的图片。得知 Stable Diffusion 3 开源后，社区用户们纷纷上手测试，在网上分享了许多测试结果。而在本文中，我将面向之前已经熟悉">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/1.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/2.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/3.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/4.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/5.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/6.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/7.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/8.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/9.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/10.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/11.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/12.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/13.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/14.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/15.jpg">
<meta property="og:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/9.jpg">
<meta property="article:published_time" content="2024-07-14T02:26:06.000Z">
<meta property="article:modified_time" content="2024-08-19T13:01:11.169Z">
<meta property="article:author" content="Zhou Yifan">
<meta property="article:tag" content="深度学习">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="扩散模型">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhouyifan.net/2024/07/14/20240703-SD3/1.jpg">

<link rel="canonical" href="https://zhouyifan.net/en/2024/07/14/20240703-SD3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Stable Diffusion 3 论文及源码概览 | 周弈帆的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/en/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">周弈帆的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/en/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/en/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/en/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/en/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/en/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-switch_lang">

    <a href="https://zhouyifan.net" rel="section"><i class="fa fa-language fa-fw"></i>简体中文</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zhouyifan.net/en/2024/07/14/20240703-SD3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/en/images/avatar.gif">
      <meta itemprop="name" content="Zhou Yifan">
      <meta itemprop="description" content="Designer, artist, philosopher, researcher.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="周弈帆的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Stable Diffusion 3 论文及源码概览
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-14 10:26:06" itemprop="dateCreated datePublished" datetime="2024-07-14T10:26:06+08:00">2024-07-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/en/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/en/categories/%E5%AD%A6%E4%B9%A0/%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">代码阅读</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>近期，最受开源社区欢迎的文生图模型 Stable Diffusion 的最新版本 Stable Diffusion 3 开放了源码和模型参数。开发者宣称，Stable Diffusion 3 使用了全新的模型结构和文本编码方法，能够生成更符合文本描述且高质量的图片。得知 Stable Diffusion 3 开源后，社区用户们纷纷上手测试，在网上分享了许多测试结果。而在本文中，我将面向之前已经熟悉 Stable Diffusion 的科研人员，快速讲解 Stable Diffusion 3 论文的主要内容及其在 Diffusers 中的源码。对于 Stable Diffusion 3 中的一些新技术，我并不会介绍其细节，而是会讲清其设计动机并指明进一步学习的参考文献。</p>
<h2 id="内容索引"><a href="#内容索引" class="headerlink" title="内容索引"></a>内容索引</h2><p>本文会从多个角度简单介绍 SD3，具体要介绍的方面如下所示。读者可以根据自己的需求，跳转到感兴趣的部分阅读。</p>
<h3 id="流匹配原理简介"><a href="#流匹配原理简介" class="headerlink" title="流匹配原理简介"></a>流匹配原理简介</h3><p>流匹配是一种定义图像生成目标的方法，它可以兼容当前扩散模型的训练目标。流匹配中一个有代表性的工作是整流 (rectified flow)，它也正是 SD3 用到的训练目标。我们会在本文中通过简单的可视化示例学习流匹配的思想。</p>
<h3 id="SD3-中的-DiT"><a href="#SD3-中的-DiT" class="headerlink" title="SD3 中的 DiT"></a>SD3 中的 DiT</h3><p>我们会从一个简单的类 ViT 架构开始，学习 SD3 中的去噪网络 DiT 模型是怎么一步一步搭起来的。读者不需要提前学过 DiT，只需要了解 Transformer 的结构，并大概知道视觉任务里的 Transformer 会做哪些通用的修改（如图块化），即可学懂 SD3 里的 DiT。</p>
<h3 id="SD3-模型与训练策略改进细节"><a href="#SD3-模型与训练策略改进细节" class="headerlink" title="SD3 模型与训练策略改进细节"></a>SD3 模型与训练策略改进细节</h3><p>除了将去噪网络从 U-Net 改成 DiT 外，SD3 还在模型结构与训练策略上做了很多小改进：</p>
<ul>
<li>改变训练时噪声采样方法</li>
<li>将一维位置编码改成二维位置编码</li>
<li>提升 VAE 隐空间通道数</li>
<li>对注意力 QK 做归一化以确保高分辨率下训练稳定</li>
</ul>
<p>本文会简单介绍这些改进。</p>
<h3 id="大型消融实验"><a href="#大型消融实验" class="headerlink" title="大型消融实验"></a>大型消融实验</h3><p>对于想训练大型文生图模型的开发者，SD3 论文提供了许多极有价值的大型消融实验结果。本文会简单分析论文中的两项实验结果：各训练目标在文生图任务中的表现、SD3 的参数扩增实验结果。</p>
<h3 id="SD3-Diffusers-源码解读"><a href="#SD3-Diffusers-源码解读" class="headerlink" title="SD3 Diffusers 源码解读"></a>SD3 Diffusers 源码解读</h3><p>本文会介绍如何配置 Diffusers 环境以用代码运行 SD3，并简单介绍相比于 SD，SD3 的采样代码和模型代码有哪些变动。</p>
<h2 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h2><h3 id="核心贡献"><a href="#核心贡献" class="headerlink" title="核心贡献"></a>核心贡献</h3><p>介绍 Stable Diffusion 3 (SD3) 的文章标题为 <em>Scaling Rectified Flow Transformers for High-Resolution Image Synthesis</em>。与其说它是一篇技术报告，更不如说它是一篇论文，因为它确实是按照撰写学术论文的一般思路，将正文的叙述重点放到了方法的核心创新点上，而没有过多叙述工程细节。正如其标题所示，这篇文章的内容很简明，就是用<strong>整流 (rectified flow)</strong> 生成模型、<strong>Transformer</strong> 神经网络做了模型<strong>参数扩增</strong>实验，以实现高质量文生图大模型。</p>
<p>由于这是一篇实验主导而非思考主导的文章，论文的开头没有太多有价值的内容。从我们读者学习论文的角度，文章的核心贡献如下：</p>
<p>从方法设计上：</p>
<ul>
<li>首次在大型文生图模型上使用了整流模型。</li>
<li>用一种新颖的 Diffusion Transformer (DiT) 神经网络来更好地融合文本信息。</li>
<li>使用了各种小设计来提升模型的能力。如使用二维位置编码来实现任意分辨率的图像生成。</li>
</ul>
<p>从实验上：</p>
<ul>
<li>开展了一场大规模、系统性的实验，以验证哪种扩散模型/整流模型的学习目标最优。</li>
<li>开展了扩增模型参数的实验 (scaling study)，以证明提升参数量能提升模型的效果。</li>
</ul>
<h3 id="整流模型简介"><a href="#整流模型简介" class="headerlink" title="整流模型简介"></a>整流模型简介</h3><p>由于 SD3 最后用了整流模型来建模图像生成，所以文章是从一种称为流匹配 (Flow Matching) 的角度而非更常见的扩散模型的角度来介绍各种训练目标。鉴于 SD3 并没有对其他论文中提出的整流模型做太多更改，我们在阅读本文时可以主要关注整流的想法及其与扩散模型的关系，后续再从其他论文中学习整流的具体原理。在此，我们来大致认识一下流匹配与整流的想法。</p>
<p>所谓图像生成，其实就是让神经网络模型学习一个图像数据集所表示的分布，之后从分布里随机采样。比如我们想让模型生成人脸图像，就是要让模型学习一个人脸图像集的分布。为了直观理解，我们可以用二维点来表示一张图像的数据。比如在下图中我们希望学习红点表示的分布，即我们希望随机生成点，生成的点都落在红点处，而不是落在灰点处。</p>
<p><img src="/2024/07/14/20240703-SD3/1.jpg" alt></p>
<p>我们很难表示出一个适合采样的复杂分布。因此，我们会把学习一个分布的问题转换成学习一个简单好采样的分布到复杂分布的映射。一般这个简单分布都是标准正态分布。如下图所示，我们可以用简单的算法采样在原点附近的来自标准正态分布的蓝点，我们要想办法得到蓝点到红点的映射方法。</p>
<p><img src="/2024/07/14/20240703-SD3/2.jpg" alt></p>
<p>学习这种映射依然是很困难的。而近年来包括扩散模型在内的几类生成模型用一种巧妙的方法来学习这种映射：从纯噪声（标准正态分布里的数据）到真实数据的映射很难表示，但从真实数据到纯噪声的逆映射很容易表示。所以，我们先人工定义从图像数据集到噪声的变换路线（红线），再让模型学习逆路线（蓝线）。让噪声数据沿着逆路线走，就实现了图像生成。</p>
<p><img src="/2024/07/14/20240703-SD3/3.jpg" alt></p>
<p>我们又可以用一种巧妙的方法间接学习图像生成路线。知道了预定义的数据到噪声的路线后，我们其实就知道了数据在路线上每一位置的速度（红箭头）。那么，我们可以以每一位置的反向速度（蓝箭头）为真值，学习噪声到真实数据的速度场。这样的学习目标被称为流匹配。</p>
<p><img src="/2024/07/14/20240703-SD3/4.jpg" alt></p>
<p>对于不同的扩散模型及流匹配模型，其本质区别在于图像到噪声的路线的定义方式。在扩散模型中，图像到噪声的路线是由一个复杂的公式表示的。而整流模型将图像到噪声的路线定义为了直线。比如根据论文的介绍，整流中 $t$ 时刻数据 $z_t$ 由真实图像 $x_0$ 变换成纯噪声 $\epsilon$ 的位置为:</p>
<script type="math/tex; mode=display">
z_t = (1 - t) x_0 + t \epsilon</script><p>而较先进的扩散模型 EDM 提出的路线公式为（$b_t$ 是一个形式较为复杂的变量）：</p>
<script type="math/tex; mode=display">
z_t = x_0 + b_t \epsilon</script><p>由于整流最后学习出来的生成路线近乎是直线，这种模型在设计上就支持少步数生成。</p>
<blockquote>
<p>虽然整流模型是这样宣传的，但实际上 SD3 还是默认用了 28 步来生成图像。单看这篇文章，原整流论文里的很多设计并没有用上。对整流感兴趣的话，可以去阅读原论文 <em>Flow straight and fast: Learning to generate and transfer data with rectified flow</em></p>
<p>流匹配模型和扩散模型的另一个区别是，流匹配模型天然支持 image2image 任务。从纯噪声中生成图像只是流匹配模型的一个特例。</p>
</blockquote>
<h3 id="非均匀训练噪声采样"><a href="#非均匀训练噪声采样" class="headerlink" title="非均匀训练噪声采样"></a>非均匀训练噪声采样</h3><p>在学习这样一种生成模型时，会先随机采样一个时刻 $t \in [0, 1]$，根据公式获取此时刻对应位置在生成路线上的速度，再让神经网络学习这个速度。直观上看，刚开始和快到终点的路线很好学，而路线的中间处比较难学。因此，在采样时刻 $t$ 时，SD3 使用了一种非均匀采样分布。</p>
<p>如下图所示，SD3 主要考虑了两种公式: mode（左）和 logit-norm （右）。二者的共同点是中间多，两边少。mode 相比 logit-norm，在开始和结束时概率不会过分接近 0。</p>
<p><img src="/2024/07/14/20240703-SD3/5.jpg" alt></p>
<h3 id="网络整体架构"><a href="#网络整体架构" class="headerlink" title="网络整体架构"></a>网络整体架构</h3><p>以上内容都是和训练相关的理论基础，下面我们来看多数用户更加熟悉的文生图架构。</p>
<p>从整体架构上来看，和之前的 SD 一样，SD3 主要基于隐扩散模型（latent diffusion model, LDM）。这套方法是一个两阶段的生成方法：先用一个 LDM 生成隐空间低分辨率的图像，再用一个自编码器把图像解码回真实图像。</p>
<p>扩散模型 LDM 会使用一个神经网络模型来对噪声图像去噪。为了实现文生图，该去噪网络会以输入文本为额外约束。相比之前多数扩散模型，SD3 的主要改进是把去噪模型的结构从 U-Net 变为了 DiT。</p>
<blockquote>
<p>DiT 的论文为 <em>Scalable Diffusion Models with Transformers</em>。如果只是对 DiT 的结构感兴趣的话，可以去直接通过读 SD3 的源码来学习。读 DiT 论文时只需要着重学习 AdaLayerNormZero 模块。</p>
</blockquote>
<h3 id="提升自编码器通道数"><a href="#提升自编码器通道数" class="headerlink" title="提升自编码器通道数"></a>提升自编码器通道数</h3><p>在当时设计整套自编码器 + LDM 的生成架构时，SD 的开发者并没有仔细改进自编码器，用了一个能把图像下采样 8 倍，通道数变为 4 的隐空间图像。比如输入 $512 \times 512 \times 3$ 的图像会被自编码器编码成 $64 \times 64 \times 4$。而近期有些工作发现，这个自编码器不够好，提升隐空间的通道数能够提升自编码器的重建效果。因此，SD3 把隐空间图像的通道数从 $4$ 改为了 $16$。</p>
<h3 id="多模态-DiT-MM-DiT"><a href="#多模态-DiT-MM-DiT" class="headerlink" title="多模态 DiT (MM-DiT)"></a>多模态 DiT (MM-DiT)</h3><p>SD3 的去噪模型是一个 Diffusion Transformer (DiT)。如果去噪模型只有带噪图像这一种输入的话，DiT 则会是一个结构非常简单的模型，和标准 ViT 一样：图像过图块化层 (Patching) 并与位置编码相加，得到序列化的数据。这些数据会像标准 Transformer 一样，经过若干个子模块，再过反图块层得到模型输出。DiT 的每个子模块 DiT-Block 和标准 Transformer 块一样，由 LayerNorm, Self-Attention, 一对一线性层 (Pointwise Feedforward, FF) 等模块构成。</p>
<blockquote>
<p>图块化层会把 $2\times2$ 个像素打包成图块，反图块化层则会把图块还原回像素。</p>
</blockquote>
<p><img src="/2024/07/14/20240703-SD3/6.jpg" alt></p>
<p>然而，扩散模型中的去噪网络一定得支持带约束生成。这是因为扩散模型约束于去噪时刻 $t$。此外，作为文生图模型，SD3 还得支持文本约束。DiT 及本文的 MM-DiT 把模型设计的重点都放在了处理额外约束上。</p>
<p>我们先看一下模块是怎么处理较简单的时刻约束的。此处，如下图所示，SD3 的模块保留了 DiT 的设计，用自适应 LayerNorm (Adaptive LayerNorm, AdaLN) 来引入额外约束。具体来说，过了 LayerNorm 后，数据的均值、方差会根据时刻约束做调整。另外，过完 Attention 层或 FF 层后，数据也会乘上一个和约束相关的系数。</p>
<p><img src="/2024/07/14/20240703-SD3/7.jpg" alt></p>
<p>我们再来看文本约束的处理。文本约束以两种方式输入进模型：与时刻编码拼接、在注意力层中融合。具体数据关联细节可参见下图。如图所示，为了提高 SD3 的文本理解能力，描述文本 (“Caption”) 经由三种编码器编码，得到两组数据。一组较短的数据会经由 MLP 与文本编码加到一起；另一组数据会经过线性层，输入进 Transformer 的主模块中。</p>
<blockquote>
<p>将约束编码与时刻编码相加是一种很常见的做法。此前 U-Net 去噪网络中处理简单约束（如 ImageNet 类型约束）就是用这种方法。</p>
</blockquote>
<p><img src="/2024/07/14/20240703-SD3/8.jpg" alt></p>
<p>SD3 的 DiT 的子模块结构图如下所示。我们可以分几部分来看它。先看时刻编码 $y$ 的那些分支。和标准 DiT 子模块一样，$y$ 通过修改 LayerNorm 后数据的均值、方差及部分层后的数据大小来实现约束。再看输入的图像编码 $x$ 和文本编码 $c$。二者以相同的方式做了 DiT 里的 LayerNorm, FF 等操作。不过，相比此前多数基于 DiT 的模型，此模块用了一种特殊的融合注意力层。具体来说，在过注意力层之前，$x$ 和 $c$ 对应的 $Q, K, V$ 会分别拼接到一起，而不是像之前的模型一样，$Q$ 来自图像，$K, V$ 来自文本。过完注意力层，输出的数据会再次拆开，回到原本的独立分支里。由于 Transformer 同时处理了文本、图像的多模态信息，所以作者将模型取名为 MM-DiT (Multimodal DiT)。</p>
<p><img src="/2024/07/14/20240703-SD3/9.jpg" alt></p>
<blockquote>
<p>论文里讲:「这个结构可以等价于两个模态各有一个 Transformer，但是在注意力操作时做了拼接，使得两种表示既可以在独自的空间里工作也可以考虑到另一个表示。」然而，我不太喜欢这种尝试去凭空解读神经网络中间表示的表述。仅从数据来源来看，过了一个注意力层后，图像信息和文本信息就混在了一起。你很难说，也很难测量，之后的 $x$ 主要是图像信息，$c$ 主要是文本信息。只能说 $x, c$ 都蕴含了多模态的信息。之前 SD U-Net 里的 $x, c$ 可以认为是分别包含了图像信息和文本信息，因为之前的 $x$ 保留了二维图像结构，而 $c$ 仅由文本信息决定。</p>
</blockquote>
<h3 id="比例可变的位置编码"><a href="#比例可变的位置编码" class="headerlink" title="比例可变的位置编码"></a>比例可变的位置编码</h3><p>此前多数方法在使用类 ViT 架构时，都会把图像的图块从左上到右下编号，把二维图块拆成一维序列，再用这种一维位置编码来对待图块。</p>
<p><img src="/2024/07/14/20240703-SD3/10.jpg" alt></p>
<p>这样做有一个很大的坏处：生成的图像的分辨率是无法修改的。比如对于上图，假如采样时输入大小不是 $4 \times 4$，而是 $4 \times 5$，那么 $0$ 号图块的下面就是 $5$ 而不是 $4$ 了，模型训练时学习到的图块之间的位置关系全部乱套。</p>
<p>解决此问题的方法很简单，只需要将一维的编码改为二维编码。这样 Transformer 就不会搞混二维图块间的关系了。</p>
<p><img src="/2024/07/14/20240703-SD3/11.jpg" alt></p>
<p>SD3 的 MM-DiT 一开始是在 $256^2$ 固定分辨率上训练的。之后在高分辨率图像上训练时，开发者用了一些巧妙的位置编码设置技巧，让不同比例的高分辨率图像也能共享之前学到的这套位置编码。详细公式请参见原论文。</p>
<h3 id="训练数据预处理"><a href="#训练数据预处理" class="headerlink" title="训练数据预处理"></a>训练数据预处理</h3><p>看完了模块设计，我们再来看一下 SD3 在训练中的一些额外设计。在大规模训练前，开发者用三个方式过滤了数据：</p>
<ol>
<li>用了一个 NSFW 过滤器过滤图片，似乎主要是为了过滤色情内容。</li>
<li>用美学打分器过滤了美学分数太低的图片。</li>
<li>移除了看上去语义差不多的图片。</li>
</ol>
<p>虽然开发者们自信满满地向大家介绍了这些数据过滤技术，但根据社区用户们的反馈，可能正是因为色情过滤器过分严格，导致 SD3 经常会生成奇怪的人体。</p>
<p>由于在训练 LDM 时，自编码器和文本编码器是不变的，因此可以提前处理好所有训练数据的图像编码和文本编码。当然，这是一项非常基础的工程技巧，不应该写在正文里的。</p>
<h3 id="用-QK-归一化提升训练稳定度"><a href="#用-QK-归一化提升训练稳定度" class="headerlink" title="用 QK 归一化提升训练稳定度"></a>用 QK 归一化提升训练稳定度</h3><p>按照之前高分辨率文生图模型的训练方法，SD3 会先在 $256^2$ 的图片上训练，再在高分辨率图片上微调。然而，开发者发现，开始微调后，混合精度训练常常会训崩。根据之前工作的经验，这是由于注意力输入的熵会不受控制地增长。解决方法也很简单，只要在做注意力计算之前对 Q, K 做一次归一化就行，具体做计算的位置可以参考上文模块图中的 “RMSNorm”。不过，开发者也承认，这个技巧并不是一个长久之策，得具体问题具体分析。看来这种 DiT 模型在大规模训练时还是会碰到许多训练不稳定的问题，且这些问题没有一个通用解。 </p>
<h3 id="哪种扩散模型训练目标最适合文生图任务？"><a href="#哪种扩散模型训练目标最适合文生图任务？" class="headerlink" title="哪种扩散模型训练目标最适合文生图任务？"></a>哪种扩散模型训练目标最适合文生图任务？</h3><p>最后我们来看论文的实验结果部分。首先，为了寻找最好的扩散模型/流匹配模型，开发者开展了一场声势浩大的实验。实验涉及 61 种训练公式，其中的可变项有：</p>
<ul>
<li>对于普通扩散模型，考虑 $\epsilon$- 或 $\mathbf{v}$-prediction，考虑线性或 cosine 噪声调度。</li>
<li>对于整流，考虑不同的噪声调度。</li>
<li>对于 EDM，考虑不同的噪声调度，且尽可能与整流的调度机制相近以保证可比较。</li>
</ul>
<p>在训练时，除了训练目标公式可变外，优化算法、模型架构、数据集、采样器都不可变。所有模型在 ImageNet 和 CC12M 数据集上训练，在 COCO-2014 验证集上评估 FID 和 CLIP Score。根据评估结果，可以选出每个模型的最优停止训练的步数。基于每种目标下的最优模型，开发者对模型进行最后的排名。由于在最终评估时，仍有采样步数、是否使用 EMA 模型等可变采样配置，开发者在所有 24 种采样配置下评估了所有模型，并用一种算法来综合所有采样配置的结果，得到一个所有模型的最终排名。最终的排名结果如下面的表 1 所示。训练集上的一些指标如表 2 所示。</p>
<p><img src="/2024/07/14/20240703-SD3/12.jpg" alt></p>
<p>根据实验结果，我们可以得到一些直观的结论：整流领先于扩散模型。惊人的是，较新推出的 EDM 竟然没有战胜早期的 LDM (“eps/linear”)。</p>
<p>当然，我个人认为，应该谨慎看待这份实验结果。一般来说，大家做图像生成会用一个统一的指标，比如 ImageNet 上的 FID。这篇论文相当于是新提出了一种昂贵的评价方法。这种评价方法是否合理，是否能得到公认还犹未可知。另外，想说明一个生成模型的拟合能力不错，用 ImageNet 上的 FID 指标就足够有说服力了，大家不会对一个简单的生成模型有太多要求。然而，对于大型文生图模型，大家更关心的是模型的生成效果，而 FID 和 CLIP Score 并不能直接反映文生图模型的质量。因此，光凭这份实验结果，我们并不能说整流一定比之前的扩散模型要好。</p>
<p>会关注这份实验结果的应该都是公司里的文生图开发者。我建议体量小的公司直接参考这份实验结果，无脑使用整流来代替之前的训练目标。而如果有能力做同等级的实验的话，则不应该错过改良后的扩散模型，如最新的 EDM2，说不定以后还会有更好的文生图训练目标。</p>
<h3 id="参数扩增实验结果"><a href="#参数扩增实验结果" class="headerlink" title="参数扩增实验结果"></a>参数扩增实验结果</h3><p>现在多数生成模型都会做参数扩增实验，即验证模型表现随参数量增长而增长，确保模型在资源足够的情况下可以被训练成「大模型」。SD3 也做了类似的实验。开发者用参数 $d$ 来控制 MM-DiT 的大小，Transformer 块的个数为 $d$，且所有特征的通道数与 $d$ 成正比。开发者在 $256^2$ 的数据上训练了所有模型 500k 步，每 50k 步在 CoCo 数据集上统计验证误差。最终所有评估指标如下图所示。可以说，所有指标都表明，模型的表现的确随参数量增长而增长。更多结果请参见论文。</p>
<p><img src="/2024/07/14/20240703-SD3/13.jpg" alt></p>
<h2 id="Diffusers-源码阅读"><a href="#Diffusers-源码阅读" class="headerlink" title="Diffusers 源码阅读"></a>Diffusers 源码阅读</h2><h3 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h3><p>我们来阅读一下 SD3 在最流行的扩散模型框架 Diffusers 中的源码。在读源码前，我们先来跑通官方的示例脚本。</p>
<p>由于使用协议的限制，SD3 的环境搭起来稍微有点麻烦。首先，我们要确保 Diffuers 和 Transformers 都用的是最新版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade diffusers transformers</span><br></pre></td></tr></table></figure>
<p>之后，我们要注册 HuggingFace 账号，再在 SD3 的模型网站 <code>https://huggingface.co/stabilityai/stable-diffusion-3-medium</code> 里确认同意某些使用协议。之后，我们要设置 Access Token。具体操作如下所示，先点右上角的 “settings”，再点左边的 “Access Tokens”，创建一个新 token。将这个 token 复制保存在本地后，点击 token 右上角选项里的 “Edit Permission”，在权限里开启 “… public gated repos …”。</p>
<p><img src="/2024/07/14/20240703-SD3/14.jpg" alt></p>
<p>最后，我们用命令行登录 HuggingFace 并使用 SD3。先用下面的命令安装 HuggingFace 命令行版。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U &quot;huggingface_hub[cli]&quot;</span><br></pre></td></tr></table></figure>
<p>再输入 <code>huggingface-cli login</code>，命令行会提示输入 token 信息。把刚刚保存好的 token 粘贴进去，即可完成登录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">huggingface-cli login</span><br><span class="line"></span><br><span class="line">Enter your token (input will not be visible): 在这里粘贴 token</span><br></pre></td></tr></table></figure>
<p>做完准备后，我们就可以执行下面的测试脚本了。注意，该脚本会自动下载模型，我们需要保证当前环境能够访问 HuggingFace。执行完毕后，生成的 $1024 \times 1024$ 大小的图片会保存在 <code>tmp.png</code> 里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> StableDiffusion3Pipeline</span><br><span class="line"></span><br><span class="line">pipe = StableDiffusion3Pipeline.from_pretrained(</span><br><span class="line">    <span class="string">&quot;stabilityai/stable-diffusion-3-medium-diffusers&quot;</span>, torch_dtype=torch.float16)</span><br><span class="line">pipe = pipe.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line">image = pipe(</span><br><span class="line">    <span class="string">&quot;A cat holding a sign that says hello world&quot;</span>,</span><br><span class="line">    negative_prompt=<span class="string">&quot;&quot;</span>,</span><br><span class="line">    num_inference_steps=<span class="number">28</span>,</span><br><span class="line">    guidance_scale=<span class="number">7.0</span>,</span><br><span class="line">).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">image.save(<span class="string">&#x27;tmp.png&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我得到的图片如下所示。看起来 SD3 理解文本的能力还是挺强的。</p>
<p><img src="/2024/07/14/20240703-SD3/15.jpg" alt></p>
<h3 id="模型组件"><a href="#模型组件" class="headerlink" title="模型组件"></a>模型组件</h3><p>接下来我们来快速浏览一下 SD3 流水线 <code>StableDiffusion3Pipeline</code> 的源码。在 IDE 里使用源码跳转功能可以在 <code>diffusers/pipelines/stable_diffusion_3/pipeline_stable_diffusion_3.py</code> 里找到该类的源码。</p>
<p>通过流水线的 <code>__init__</code> 方法，我们能知道 SD3 的所有组件。组件包括自编码器 <code>vae</code>, MM-DiT <code>Transformer</code>, 流匹配噪声调度器 <code>scheduler</code>，以及三个文本编码器。每个编码器由一个 tokenizer 和一个 text encoder 组成.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    self,</span></span></span><br><span class="line"><span class="params"><span class="function">    transformer: SD3Transformer2DModel,</span></span></span><br><span class="line"><span class="params"><span class="function">    scheduler: FlowMatchEulerDiscreteScheduler,</span></span></span><br><span class="line"><span class="params"><span class="function">    vae: AutoencoderKL,</span></span></span><br><span class="line"><span class="params"><span class="function">    text_encoder: CLIPTextModelWithProjection,</span></span></span><br><span class="line"><span class="params"><span class="function">    tokenizer: CLIPTokenizer,</span></span></span><br><span class="line"><span class="params"><span class="function">    text_encoder_2: CLIPTextModelWithProjection,</span></span></span><br><span class="line"><span class="params"><span class="function">    tokenizer_2: CLIPTokenizer,</span></span></span><br><span class="line"><span class="params"><span class="function">    text_encoder_3: T5EncoderModel,</span></span></span><br><span class="line"><span class="params"><span class="function">    tokenizer_3: T5TokenizerFast,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>):</span></span><br></pre></td></tr></table></figure>
<p><code>vae</code> 的用法和之前 SD 的一模一样，编码时用 <code>vae.encode</code> 并乘 <code>vae.config.scaling_factor</code>，解码时除以 <code>vae.config.scaling_factor</code> 并用 <code>vae.decode</code>。</p>
<p>文本编码器的用法可以参见 <code>encode_prompt</code> 方法。文本会分别过各个编码器的 tokenizer 和 text encoder，得到三种文本编码，并按照论文中的描述拼接成两种约束信息。这部分代码十分繁杂，多数代码都是在处理数据形状，没有太多有价值的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_prompt</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        prompt,</span></span></span><br><span class="line"><span class="params"><span class="function">        prompt_2,</span></span></span><br><span class="line"><span class="params"><span class="function">        prompt_3,</span></span></span><br><span class="line"><span class="params"><span class="function">        device,</span></span></span><br><span class="line"><span class="params"><span class="function">        num_images_per_prompt,</span></span></span><br><span class="line"><span class="params"><span class="function">        do_classifier_free_guidance,</span></span></span><br><span class="line"><span class="params"><span class="function">        negative_prompt,</span></span></span><br><span class="line"><span class="params"><span class="function">        negative_prompt_2,</span></span></span><br><span class="line"><span class="params"><span class="function">        negative_prompt_3,</span></span></span><br><span class="line"><span class="params"><span class="function">        ...</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prompt_embeds, negative_prompt_embeds,</span><br><span class="line">     pooled_prompt_embeds, negative_pooled_prompt_embeds</span><br></pre></td></tr></table></figure>
<h3 id="采样流水线"><a href="#采样流水线" class="headerlink" title="采样流水线"></a>采样流水线</h3><p>我们再来通过阅读流水线的 <code>__call__</code> 方法了解 SD3 采样的过程。由于 SD3 并没有修改 LDM 的这套生成框架，其采样流水线和 SD 几乎完全一致。SD3 和 SD 的 <code>__call__</code> 方法的主要区别是，生成文本编码时会生成两种编码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">    prompt_embeds,</span><br><span class="line">    negative_prompt_embeds,</span><br><span class="line">    pooled_prompt_embeds,</span><br><span class="line">    negative_pooled_prompt_embeds,</span><br><span class="line">) = self.encode_prompt(...)</span><br></pre></td></tr></table></figure>
<p>在调用去噪网络时，那个较小的文本编码 <code>pooled_prompt_embeds</code> 会作为一个额外参数输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">noise_pred = self.transformer(</span><br><span class="line">    hidden_states=latent_model_input,</span><br><span class="line">    timestep=timestep,</span><br><span class="line">    encoder_hidden_states=prompt_embeds,</span><br><span class="line">    pooled_projections=pooled_prompt_embeds,</span><br><span class="line">    joint_attention_kwargs=self.joint_attention_kwargs,</span><br><span class="line">    return_dict=<span class="literal">False</span>,</span><br><span class="line">)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="MM-DiT-去噪模型"><a href="#MM-DiT-去噪模型" class="headerlink" title="MM-DiT 去噪模型"></a>MM-DiT 去噪模型</h3><p>相比之下，SD3 的去噪网络 MM-DiT 的改动较大。我们来看一下对应的 <code>SD3Transformer2DModel</code> 类，它位于文件 <code>diffusers\models\transformers\transformer_sd3.py</code>。</p>
<p>类的构造函数里有几个值得关注的模块：二维位置编码类 <code>PatchEmbed</code>、组合时刻编码和文本编码模块 <code>CombinedTimestepTextProjEmbeddings</code>、主模块类 <code>JointTransformerBlock</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">...</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    self.pos_embed = PatchEmbed(...)</span><br><span class="line">    self.time_text_embed = CombinedTimestepTextProjEmbeddings(...)</span><br><span class="line">    ...</span><br><span class="line">    self.transformer_blocks = nn.ModuleList(</span><br><span class="line">          [</span><br><span class="line">              JointTransformerBlock(..)</span><br><span class="line">              <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.config.num_layers)</span><br><span class="line">          ]</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>
<p>类的前向传播函数 <code>forward</code> 里都是比较常规的操作。数据会依次经过前处理、若干个 Transformer 块、后处理。所有实现细节都封装在各个模块类里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">...</span>):</span></span><br><span class="line">    hidden_states = self.pos_embed(hidden_states)</span><br><span class="line">    temb = self.time_text_embed(timestep, pooled_projections)</span><br><span class="line">    encoder_hidden_states = self.context_embedder(encoder_hidden_states)</span><br><span class="line">    <span class="keyword">for</span> index_block, block <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.transformer_blocks):</span><br><span class="line">       encoder_hidden_states, hidden_states = block(...)</span><br><span class="line">    </span><br><span class="line">    encoder_hidden_states, hidden_states = block(</span><br><span class="line">    hidden_states=hidden_states, encoder_hidden_states=encoder_hidden_states, temb=temb</span><br><span class="line">)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>接下来我们来看这几个较为重要的子模块。<code>PatchEmbed</code> 类的实现写在 <code>diffusers/models/embeddings.py</code> 里。这个类的实现写得非常清晰。<code>PatchEmbed</code> 类本身用于维护位置编码宽高、特征长度这些信息，计算位置编码的关键代码在 <code>get_2d_sincos_pos_embed</code> 中。<code>get_2d_sincos_pos_embed</code> 会生成 <code>(0, 0), (1, 0), ...</code> 这样的二维坐标网格，再调用 <code>get_2d_sincos_pos_embed_from_grid</code> 生成二维位置编码。<code>get_2d_sincos_pos_embed_from_grid</code> 会调用两次一维位置编码函数 <code>get_1d_sincos_pos_embed_from_grid</code>，也就是 Transformer 里那种标准位置编码生成函数，来分别生成两个方向的编码，最后拼接成二维位置编码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatchEmbed</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, latent</span>):</span></span><br><span class="line">        ...</span><br><span class="line">        pos_embed = get_2d_sincos_pos_embed(...)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_2d_sincos_pos_embed</span>(<span class="params">...</span>):</span></span><br><span class="line">    grid_h = np.arange(...)</span><br><span class="line">    grid_w = np.arange(...)</span><br><span class="line">    grid = np.meshgrid(grid_w, grid_h)</span><br><span class="line">    ...</span><br><span class="line">    pos_embed = get_2d_sincos_pos_embed_from_grid(embed_dim, grid)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_2d_sincos_pos_embed_from_grid</span>(<span class="params">...</span>):</span></span><br><span class="line">    <span class="comment"># use half of dimensions to encode grid_h</span></span><br><span class="line">    emb_h = get_1d_sincos_pos_embed_from_grid(embed_dim // <span class="number">2</span>, grid[<span class="number">0</span>])  <span class="comment"># (H*W, D/2)</span></span><br><span class="line">    emb_w = get_1d_sincos_pos_embed_from_grid(embed_dim // <span class="number">2</span>, grid[<span class="number">1</span>])  <span class="comment"># (H*W, D/2)</span></span><br><span class="line"></span><br><span class="line">    emb = np.concatenate([emb_h, emb_w], axis=<span class="number">1</span>)  <span class="comment"># (H*W, D)</span></span><br><span class="line">    <span class="keyword">return</span> emb</span><br></pre></td></tr></table></figure>
<p>组合时刻编码和文本编码模块 <code>CombinedTimestepTextProjEmbeddings</code> 的代码非常短。它实际上就是用通常的 <code>Timesteps</code> 类获取时刻编码，用一个 <code>text_embedder</code> 模块再次处理文本编码，最后把两个编码加起来。<br><code>text_embedder</code> 是一个线性层、激活函数、线性层构成的简单模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinedTimestepTextProjEmbeddings</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, embedding_dim, pooled_projection_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.time_proj = Timesteps(num_channels=<span class="number">256</span>, flip_sin_to_cos=<span class="literal">True</span>, downscale_freq_shift=<span class="number">0</span>)</span><br><span class="line">        self.timestep_embedder = TimestepEmbedding(in_channels=<span class="number">256</span>, time_embed_dim=embedding_dim)</span><br><span class="line">        self.text_embedder = PixArtAlphaTextProjection(pooled_projection_dim, embedding_dim, act_fn=<span class="string">&quot;silu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, timestep, pooled_projection</span>):</span></span><br><span class="line">        timesteps_proj = self.time_proj(timestep)</span><br><span class="line">        timesteps_emb = self.timestep_embedder(timesteps_proj.to(dtype=pooled_projection.dtype))  <span class="comment"># (N, D)</span></span><br><span class="line"></span><br><span class="line">        pooled_projections = self.text_embedder(pooled_projection)</span><br><span class="line"></span><br><span class="line">        conditioning = timesteps_emb + pooled_projections</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conditioning</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PixArtAlphaTextProjection</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">...</span>):</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, caption</span>):</span></span><br><span class="line">        hidden_states = self.linear_1(caption)</span><br><span class="line">        hidden_states = self.act_1(hidden_states)</span><br><span class="line">        hidden_states = self.linear_2(hidden_states)</span><br><span class="line">        <span class="keyword">return</span> hidden_states</span><br></pre></td></tr></table></figure>
<p>MM-DiT 的主要模块 <code>JointTransformerBlock</code> 在 <code>diffusers/models/attention.py</code> 文件里。这个类的代码写得比较乱。它主要负责处理 LayerNorm 及数据的尺度变换操作，具体的注意力计算由注意力处理器 <code>JointAttnProcessor2_0</code> 负责。两处 LayerNorm 的实现方式竟然是不一样的。</p>
<p><img src="/2024/07/14/20240703-SD3/9.jpg" alt></p>
<p>我们先简单看一下构造函数里初始化了哪些模块。代码中，<code>norm1, ff, norm2</code> 等模块都是普通 Transformer 块中的模块。而加了 <code>_context</code> 的模块则表示处理文本分支 $c$ 的模块，如 <code>norm1_context, ff_context</code>。<code>context_pre_only</code> 表示做完了注意力计算后，还要不要给文本分支加上 LayerNorm 和 FeedForward。如前文所述，具体的注意力计算由 <code>JointAttnProcessor2_0</code> 负责。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JointTransformerBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, num_attention_heads, attention_head_dim, context_pre_only=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.context_pre_only = context_pre_only</span><br><span class="line">        context_norm_type = <span class="string">&quot;ada_norm_continous&quot;</span> <span class="keyword">if</span> context_pre_only <span class="keyword">else</span> <span class="string">&quot;ada_norm_zero&quot;</span></span><br><span class="line"></span><br><span class="line">        self.norm1 = AdaLayerNormZero(dim)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> context_norm_type == <span class="string">&quot;ada_norm_continous&quot;</span>:</span><br><span class="line">            self.norm1_context = AdaLayerNormContinuous(</span><br><span class="line">                dim, dim, elementwise_affine=<span class="literal">False</span>, eps=<span class="number">1e-6</span>, bias=<span class="literal">True</span>, norm_type=<span class="string">&quot;layer_norm&quot;</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> context_norm_type == <span class="string">&quot;ada_norm_zero&quot;</span>:</span><br><span class="line">            self.norm1_context = AdaLayerNormZero(dim)</span><br><span class="line">        </span><br><span class="line">        processor = JointAttnProcessor2_0()</span><br><span class="line">        self.attn = Attention(</span><br><span class="line">            query_dim=dim,</span><br><span class="line">            cross_attention_dim=<span class="literal">None</span>,</span><br><span class="line">            added_kv_proj_dim=dim,</span><br><span class="line">            dim_head=attention_head_dim,</span><br><span class="line">            heads=num_attention_heads,</span><br><span class="line">            out_dim=dim,</span><br><span class="line">            context_pre_only=context_pre_only,</span><br><span class="line">            bias=<span class="literal">True</span>,</span><br><span class="line">            processor=processor,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.norm2 = nn.LayerNorm(dim, elementwise_affine=<span class="literal">False</span>, eps=<span class="number">1e-6</span>)</span><br><span class="line">        self.ff = FeedForward(dim=dim, dim_out=dim, activation_fn=<span class="string">&quot;gelu-approximate&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> context_pre_only:</span><br><span class="line">            self.norm2_context = nn.LayerNorm(dim, elementwise_affine=<span class="literal">False</span>, eps=<span class="number">1e-6</span>)</span><br><span class="line">            self.ff_context = FeedForward(dim=dim, dim_out=dim, activation_fn=<span class="string">&quot;gelu-approximate&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.norm2_context = <span class="literal">None</span></span><br><span class="line">            self.ff_context = <span class="literal">None</span>     </span><br></pre></td></tr></table></figure>
<p>我们再来看 <code>forward</code> 方法。在前向传播时，图像分支和文本分支会分别过 <code>norm1</code>，再一起过注意力操作，再分别过 <code>norm2</code> 和 <code>ff</code>。大概的代码如下所示，我把较复杂的 context 分支的代码略过了。</p>
<p>这份代码写得很不漂亮，按理说模块里两个 LayerNorm + 尺度变换 (即 Adaptive LayerNorm) 的操作是一样的，应该用同样的代码来处理。但是这个模块里 <code>norm1</code> 是 <code>AdaLayerNormZero</code> 类，<code>norm2</code> 是 <code>LayerNorm</code> 类。<code>norm1</code> 会自动做完 AdaLayerNorm 的运算，并把相关变量返回。而在 <code>norm2</code> 处，代码会先执行普通的 LayerNorm，再根据之前的变量手动调整数据的尺度。我们心里知道这份代码是在实现论文里那张结构图就好，没必要去仔细阅读。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    self, hidden_states: torch.FloatTensor, encoder_hidden_states: torch.FloatTensor, temb: torch.FloatTensor</span></span></span><br><span class="line"><span class="params"><span class="function"></span>):</span></span><br><span class="line">    norm_hidden_states, gate_msa, shift_mlp, scale_mlp, gate_mlp = self.norm1(hidden_states, emb=temb)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.context_pre_only:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attention.</span></span><br><span class="line">    attn_output, context_attn_output = self.attn(</span><br><span class="line">        hidden_states=norm_hidden_states, encoder_hidden_states=norm_encoder_hidden_states</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process attention outputs for the `hidden_states`.</span></span><br><span class="line">    attn_output = gate_msa.unsqueeze(<span class="number">1</span>) * attn_output</span><br><span class="line">    hidden_states = hidden_states + attn_output</span><br><span class="line"></span><br><span class="line">    norm_hidden_states = self.norm2(hidden_states)</span><br><span class="line">    norm_hidden_states = norm_hidden_states * (<span class="number">1</span> + scale_mlp[:, <span class="literal">None</span>]) + shift_mlp[:, <span class="literal">None</span>]</span><br><span class="line">    ff_output = self.ff(norm_hidden_states)</span><br><span class="line">    ff_output = gate_mlp.unsqueeze(<span class="number">1</span>) * ff_output</span><br><span class="line"></span><br><span class="line">    hidden_states = hidden_states + ff_output</span><br><span class="line">    <span class="keyword">if</span> self.context_pre_only:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoder_hidden_states, hidden_states</span><br></pre></td></tr></table></figure>
<p>融合注意力的实现方法很简单。和普通的注意力计算相比，这种注意力就是把另一条数据分支 <code>encoder_hidden_states</code> 也做了 QKV 的线性变换，并在做注意力运算前与原来的 QKV 拼接起来。做完注意力运算后，两个数据又会拆分回去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JointAttnProcessor2_0</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Attention processor used typically in processing the SD3-like self-attention projections.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        self,</span></span></span><br><span class="line"><span class="params"><span class="function">        attn: Attention,</span></span></span><br><span class="line"><span class="params"><span class="function">        hidden_states: torch.FloatTensor,</span></span></span><br><span class="line"><span class="params"><span class="function">        encoder_hidden_states: torch.FloatTensor = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        *args,</span></span></span><br><span class="line"><span class="params"><span class="function">        **kwargs,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) -&gt; torch.FloatTensor:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># `sample` projections.</span></span><br><span class="line">        query = attn.to_q(hidden_states)</span><br><span class="line">        key = attn.to_k(hidden_states)</span><br><span class="line">        value = attn.to_v(hidden_states)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># `context` projections.</span></span><br><span class="line">        encoder_hidden_states_query_proj = attn.add_q_proj(encoder_hidden_states)</span><br><span class="line">        encoder_hidden_states_key_proj = attn.add_k_proj(encoder_hidden_states)</span><br><span class="line">        encoder_hidden_states_value_proj = attn.add_v_proj(encoder_hidden_states)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># attention</span></span><br><span class="line">        query = torch.cat([query, encoder_hidden_states_query_proj], dim=<span class="number">1</span>)</span><br><span class="line">        key = torch.cat([key, encoder_hidden_states_key_proj], dim=<span class="number">1</span>)</span><br><span class="line">        value = torch.cat([value, encoder_hidden_states_value_proj], dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Split the attention outputs.</span></span><br><span class="line">        hidden_states, encoder_hidden_states = (</span><br><span class="line">            hidden_states[:, : residual.shape[<span class="number">1</span>]],</span><br><span class="line">            hidden_states[:, residual.shape[<span class="number">1</span>] :],</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们学习了 SD3 论文及源码中的主要内容。相比于 SD，SD3 做了两项较大的改进：用整流代替原来的 DDPM 中的训练目标；将去噪模型从 U-Net 变成了能更好地处理多模态信息的 MM-DiT。SD3 还在模型结构和训练目标上做了许多小改进，如调整训练噪声采样分布、使用二维位置编码。SD3 论文展示了多项大型消融实验的结果，证明当前的 SD3 是以最优配置训练得到的。SD3 可以在 Diffusers 中使用。当然，由于 SD3 的使用协议较为严格，我们需要做一些配置，才能在代码中使用 SD3。SD3 的采样流水线基本没变，原来 SD 的多数编辑方法能够无缝迁移过来。而 SD3 的去噪模型变动较大，和 U-Net 相关的编辑方法则无法直接用过来。在学习源码时，主要值得学习的是新 MM-DiT 模型中每个 Transformer 层的实现细节。</p>
<p>尽管 SD3 并没有提出新的流匹配方法，但其实验结果表明流匹配模型可能更适合文生图任务。作为研究者，受此启发，我们或许需要关注一下整流等流匹配模型，知道它们的思想，分析它们与原扩散模型训练目标的异同，以拓宽自己的视野。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/en/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag"># 深度学习</a>
              <a href="/en/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
              <a href="/en/tags/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B/" rel="tag"># 扩散模型</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/en/2024/06/24/20240622-CVPR2024/" rel="prev" title="顽抗生活中的厄运">
      <i class="fa fa-chevron-left"></i> 顽抗生活中的厄运
    </a></div>
      <div class="post-nav-item">
    <a href="/en/2024/07/27/20240605-diffusers-training/" rel="next" title="定制适合自己的 Diffusers 扩散模型训练脚本">
      定制适合自己的 Diffusers 扩散模型训练脚本 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E7%B4%A2%E5%BC%95"><span class="nav-number">1.</span> <span class="nav-text">内容索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">流匹配原理简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SD3-%E4%B8%AD%E7%9A%84-DiT"><span class="nav-number">1.2.</span> <span class="nav-text">SD3 中的 DiT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SD3-%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%AE%AD%E7%BB%83%E7%AD%96%E7%95%A5%E6%94%B9%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="nav-number">1.3.</span> <span class="nav-text">SD3 模型与训练策略改进细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%9E%8B%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C"><span class="nav-number">1.4.</span> <span class="nav-text">大型消融实验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SD3-Diffusers-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">1.5.</span> <span class="nav-text">SD3 Diffusers 源码解读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB"><span class="nav-number">2.</span> <span class="nav-text">论文阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E8%B4%A1%E7%8C%AE"><span class="nav-number">2.1.</span> <span class="nav-text">核心贡献</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%B5%81%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.</span> <span class="nav-text">整流模型简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%AD%E7%BB%83%E5%99%AA%E5%A3%B0%E9%87%87%E6%A0%B7"><span class="nav-number">2.3.</span> <span class="nav-text">非均匀训练噪声采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">网络整体架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8D%87%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E9%80%9A%E9%81%93%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">提升自编码器通道数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%A8%A1%E6%80%81-DiT-MM-DiT"><span class="nav-number">2.6.</span> <span class="nav-text">多模态 DiT (MM-DiT)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E4%BE%8B%E5%8F%AF%E5%8F%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81"><span class="nav-number">2.7.</span> <span class="nav-text">比例可变的位置编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">2.8.</span> <span class="nav-text">训练数据预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-QK-%E5%BD%92%E4%B8%80%E5%8C%96%E6%8F%90%E5%8D%87%E8%AE%AD%E7%BB%83%E7%A8%B3%E5%AE%9A%E5%BA%A6"><span class="nav-number">2.9.</span> <span class="nav-text">用 QK 归一化提升训练稳定度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E7%A7%8D%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E7%9B%AE%E6%A0%87%E6%9C%80%E9%80%82%E5%90%88%E6%96%87%E7%94%9F%E5%9B%BE%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="nav-number">2.10.</span> <span class="nav-text">哪种扩散模型训练目标最适合文生图任务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E6%89%A9%E5%A2%9E%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">2.11.</span> <span class="nav-text">参数扩增实验结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Diffusers-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="nav-number">3.</span> <span class="nav-text">Diffusers 源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="nav-number">3.1.</span> <span class="nav-text">测试脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">模型组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%87%E6%A0%B7%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">3.3.</span> <span class="nav-text">采样流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MM-DiT-%E5%8E%BB%E5%99%AA%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">MM-DiT 去噪模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zhou Yifan</p>
  <div class="site-description" itemprop="description">Designer, artist, philosopher, researcher.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/en/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/en/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/en/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhou Yifan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/en/lib/anime.min.js"></script>
  <script src="/en/lib/velocity/velocity.min.js"></script>
  <script src="/en/lib/velocity/velocity.ui.min.js"></script>

<script src="/en/js/utils.js"></script>

<script src="/en/js/motion.js"></script>


<script src="/en/js/schemes/muse.js"></script>


<script src="/en/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
